<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Imposter by hAiQ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: url('/images/background.png');
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            background-repeat: no-repeat;
            min-height: 100vh;
            color: white;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        /* Dark overlay for better readability */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.2);
            z-index: -1;
            pointer-events: none;
        }
        
        .container {
            max-width: 1011px;
            width: 100%;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            justify-content: center;
        }
        
        .card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.15) 100%);
            border-radius: 20px;
            padding: 30px;
            margin: 10px 0;
            backdrop-filter: blur(25px);
            border: 2px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
            width: 100%;
            max-width: 500px;
        }
        
        /* Larger cards for content-heavy screens */
        #stats-screen.card,
        #game-screen.card,
        #lobby-screen.card {
            max-width: 800px;
        }
        
        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 30px 60px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .hidden {
            display: none;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 40px;
            font-size: 3.5em;
            font-weight: 700;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4);
            background-size: 400% 400%;
            animation: gradientShift 8s ease infinite;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: none;
            letter-spacing: -1px;
        }
        
        /* Logo Styles */
        .logo-container {
            text-align: center;
            margin-bottom: 20px;
            margin-top: -50px;
            order: -1;
        }
        
        .game-logo {
            max-width: 100%;
            height: auto;
            max-height: 120px;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.3));
            transition: all 0.3s ease;
        }
        
        .game-logo:hover {
            transform: scale(1.05);
            filter: drop-shadow(0 6px 12px rgba(0, 0, 0, 0.4));
        }
        
        h2 {
            text-align: center;
            margin-bottom: 25px;
            font-size: 1.8em;
            font-weight: 600;
            color: #fff;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        input, button, select {
            width: 100%;
            padding: 16px 20px;
            margin: 12px 0;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease;
        }
        
        input, select {
            background: rgba(255, 255, 255, 0.95);
            color: #333;
            border: 2px solid transparent;
            font-weight: 500;
        }
        
        input:focus, select:focus {
            outline: none;
            border-color: #4ecdc4;
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
            transform: translateY(-2px);
        }
        
        /* Text Shadow for better readability */
        p, span, div, li, label, h1, h2, h3, h4, h5, h6, 
        .player-item, .word-item, .vote-count, #voting-status, 
        #voting-status-inline, #current-player, #current-round,
        #player-word, .game-info, .voting-section {
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
            border: none;
            position: relative;
            overflow: hidden;
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        
        button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        button:hover::before {
            left: 100%;
        }
        
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(-1px);
        }
        
        button:disabled {
            background: linear-gradient(135deg, #666 0%, #444 100%);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .primary-btn {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
        }
        
        .primary-btn:hover {
            box-shadow: 0 10px 30px rgba(78, 205, 196, 0.4);
        }
        
        .danger {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        
        .danger:hover {
            box-shadow: 0 10px 30px rgba(255, 107, 107, 0.4);
        }
        
        .copy-btn {
            background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%);
            font-size: 0.8em;
            padding: 4px 8px;
            margin-left: 8px;
            border-radius: 6px;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-block;
            min-width: auto;
            text-transform: none;
            letter-spacing: 0;
        }
        
        .copy-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(162, 155, 254, 0.4);
        }
        
        .voting-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9) 0%, rgba(30, 30, 30, 0.9) 100%);
            border: 2px solid rgba(255, 255, 255, 0.1);
            width: 90%;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .voting-screen:hover {
            transform: translate(-50%, -50%) !important;
        }
        
        .game-screen {
            position: relative;
            z-index: 1;
        }
        
        .game-players-list {
            position: fixed;
            top: 20px;
            left: 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 12px;
            padding: 15px;
            min-width: 200px;
            max-width: 250px;
            max-height: 60vh;
            overflow-y: auto;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            display: none; /* Hidden by default */
        }
        
        .game-players-list h4 {
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 1em;
            font-weight: 600;
            position: sticky;
            top: 0;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0.2) 100%);
            padding-bottom: 5px;
        }
        
        .game-players-display {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        
        .game-player-item {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 10px;
            padding: 8px 12px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #fff;
            font-size: 0.9em;
            transition: all 0.2s ease;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .game-player-item.current-player {
            background: linear-gradient(135deg, rgba(76, 205, 196, 0.3) 0%, rgba(52, 152, 219, 0.2) 100%);
            border-color: rgba(76, 205, 196, 0.4);
            font-weight: 600;
        }
        
        .players-list {
            margin: 25px 0;
        }
        
        .player {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            padding: 15px 20px;
            margin: 10px 0;
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .player:hover {
            transform: translateX(5px);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .player.host {
            background: linear-gradient(135deg, hwb(170 0% 0% / 0.2) 0%, rgba(0, 81, 255, 0.1) 100%);
            border-color: rgba(0, 46, 59, 0.4);
        }
        
        .lobby-section {
            margin-top: 40px;
        }
        
        /* Back to Main Menu Button */
        .back-to-menu-btn {
            position: fixed;
            top: 15px;
            left: 15px;
            background: linear-gradient(135deg, rgba(231, 76, 60, 0.9) 0%, rgba(192, 57, 43, 0.8) 100%);
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            z-index: 1001;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
            min-width: auto;
            white-space: nowrap;
            max-width: 80px;
            text-align: center;
        }
        
        .back-to-menu-btn:hover {
            background: linear-gradient(135deg, rgba(231, 76, 60, 1) 0%, rgba(192, 57, 43, 0.9) 100%);
            transform: translateY(-1px);
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.3);
        }
        
        .back-to-menu-btn:active {
            transform: translateY(0);
        }
        
        /* Voting Section Styles */
        #voting-section {
            margin-top: 60px; /* Space for the menu button */
            padding-top: 20px;
        }
        
        #voting-section h3 {
            margin-bottom: 20px;
            font-size: 1.5em;
            font-weight: 600;
            text-align: center;
            color: #fff;
        }
        
        .lobby-match {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12) 0%, rgba(255, 255, 255, 0.06) 100%);
            padding: 20px;
            margin: 15px 0;
            border-radius: 16px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            overflow: hidden;
        }
        
        .lobby-match::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 0.6s;
        }
        
        .lobby-match:hover::before {
            left: 100%;
        }
        
        .lobby-match:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .lobby-match-info {
            flex: 1;
            z-index: 1;
        }
        
        .lobby-match-host {
            font-weight: 600;
            color: #4ecdc4;
            font-size: 1.1em;
            margin-bottom: 5px;
        }
        
        .lobby-match-players {
            color: rgba(255, 255, 255, 0.8);
            font-size: 0.9em;
            font-weight: 500;
        }
        
        .lobby-match-join {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
            z-index: 1;
        }
        
        .lobby-match-join:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 20px rgba(78, 205, 196, 0.4);
        }
        
        .private-lobby {
            border-color: rgba(255, 107, 107, 0.4);
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.15) 0%, rgba(238, 90, 36, 0.1) 100%);
        }
        
        .private-lobby .lobby-match-host {
            color: #ff6b6b;
        }
        
        .private-lobby .lobby-match-join {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 100%);
        }
        
        .private-lobby .lobby-match-join:hover {
            box-shadow: 0 8px 20px rgba(255, 107, 107, 0.4);
        }
        
        .word-display {
            background: linear-gradient(135deg, rgba(78, 205, 196, 0.2) 0%, rgba(68, 160, 141, 0.1) 100%);
            padding: 25px;
            margin: 20px 0;
            border-radius: 16px;
            border: 2px solid rgba(78, 205, 196, 0.3);
            text-align: center;
            font-size: 1.3em;
            font-weight: 600;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .imposter-word {
            border-color: rgba(255, 107, 107, 0.4) !important;
            color: #ff6b6b !important;
        }
        
        .spectator-word {
            border-color: rgba(150, 150, 150, 0.4) !important;
            color: #999 !important;
            font-style: italic;
        }
        
        .game-info {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.08) 0%, rgba(255, 255, 255, 0.04) 100%);
            padding: 20px;
            border-radius: 14px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            margin-top: 50px;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .game-info p {
            margin: 8px 0;
            font-weight: 500;
        }
        
        .words-list {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px;
        }
        
        .words-list::-webkit-scrollbar {
            width: 8px;
        }
        
        .words-list::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .words-list::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }
        
        .words-list::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .word-entry {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            padding: 12px 16px;
            margin: 8px 0;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }
        
        .word-entry:hover {
            transform: translateX(3px);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .vote-options {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 20px 0;
        }
        
        .player-vote-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .vote-player-btn {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 15px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }
        
        .vote-player-btn:hover {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.3) 0%, rgba(238, 90, 36, 0.2) 100%);
            border-color: rgba(255, 107, 107, 0.5);
            transform: translateY(-2px);
        }
        
        .error {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.9) 0%, rgba(238, 90, 36, 0.9) 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 2px solid rgba(255, 107, 107, 0.5);
            font-weight: 500;
            text-align: center;
        }
        
        .success {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.9) 0%, rgba(56, 142, 60, 0.9) 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 12px;
            margin: 20px 0;
            border: 2px solid rgba(76, 175, 80, 0.5);
            font-weight: 500;
            text-align: center;
        }
        
        /* Fixed position messages that don't affect layout */
        #messages-container {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            pointer-events: none;
        }
        
        .error-fixed, .success-fixed {
            padding: 15px 25px;
            border-radius: 12px;
            margin: 10px 0;
            font-weight: 500;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 2px solid;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            animation: slideInUp 0.3s ease-out;
            pointer-events: auto;
        }
        
        .error-fixed {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.95) 0%, rgba(238, 90, 36, 0.95) 100%);
            color: white;
            border-color: rgba(255, 107, 107, 0.7);
        }
        
        .success-fixed {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.95) 0%, rgba(56, 142, 60, 0.95) 100%);
            color: white;
            border-color: rgba(76, 175, 80, 0.7);
        }
        
        @keyframes slideInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Auth and Stats Styles */
        .stats-overview {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
            font-size: 0.9em;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .stat-item {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .stat-item:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 255, 255, 0.3);
        }
        
        .stat-item h3 {
            font-size: 1em;
            margin-bottom: 8px;
            color: #fff;
        }
        
        .stat-item p {
            font-size: 1.5em;
            font-weight: bold;
            color: #4ecdc4;
            margin: 0;
        }
        
        a {
            color: #4ecdc4;
            text-decoration: none;
            transition: color 0.3s ease;
        }
        
        a:hover {
            color: #45b7d1;
        }
        
        /* User Profile Styles */
        .user-profile {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 15px;
            padding: 15px;
            min-width: 250px;
            z-index: 1000;
            transition: all 0.3s ease;
        }
        
        .user-profile:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
        }
        
        .profile-info {
            margin-bottom: 10px;
        }
        
        .profile-info span {
            font-weight: bold;
            color: #fff;
            font-size: 1.1em;
        }
        
        .profile-stats {
            font-size: 0.85em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }
        
        .profile-actions {
            display: flex;
            gap: 8px;
        }
        
        .profile-btn {
            flex: 1;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.1) 0%, rgba(255, 255, 255, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.85em;
            font-weight: 500;
        }
        
        .profile-btn:hover {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.1) 100%);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .logout-btn:hover {
            background: linear-gradient(135deg, rgba(255, 107, 107, 0.3) 0%, rgba(238, 90, 36, 0.2) 100%);
            border-color: rgba(255, 107, 107, 0.5);
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 15px;
                min-height: 100vh;
            }
            
            .logo-container {
                margin-top: -30px;
                margin-bottom: 15px;
            }
            
            .game-logo {
                max-height: 80px;
            }
            
            .card {
                padding: 20px;
                margin: 8px 0;
                max-width: 100%;
            }
            
            .user-profile {
                top: 10px;
                right: 10px;
                min-width: 200px;
                padding: 12px;
            }
            
            .profile-btn {
                font-size: 0.8em;
                padding: 6px 8px;
            }
            
            .vote-options {
                grid-template-columns: 1fr;
            }
            
            .player-vote-grid {
                grid-template-columns: 1fr;
            }
        }
        
        /* Countdown Screen */
        .countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            z-index: 9999;
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        
        .countdown-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        
        .countdown-window {
            background: linear-gradient(135deg, #6b73ff 0%, #9d50bb 100%);
            border-radius: 20px;
            padding: 60px 80px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 650px;
            width: 90%;
            transform: scale(0.8);
            transition: transform 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .countdown-overlay.show .countdown-window,
        .countdown-overlay.show .game-finished-window {
            transform: scale(1);
        }
        
        /* Game Finished Overlay */
        .game-finished-window {
            background: linear-gradient(135deg, #ff6b6b 0%, #ee5a24 50%, #ff9ff3 100%);
            border-radius: 25px;
            padding: 50px 60px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            max-width: 700px;
            width: 90%;
            transform: scale(0.8);
            transition: transform 0.3s ease;
            border: 3px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .game-result-icon {
            font-size: 4.5em;
            margin-bottom: 20px;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: resultIconPulse 2s ease-in-out infinite;
        }
        
        .game-result-title {
            font-size: 3em;
            font-weight: 700;
            color: white;
            margin-bottom: 30px;
            text-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        
        .game-result-content {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 25px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .game-result-content h3 {
            font-size: 1.8em;
            font-weight: 600;
            color: white;
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .game-result-content p {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .game-result-content strong {
            color: #fff;
            font-weight: 600;
        }
        
        .game-result-word {
            font-size: 1.4em;
            font-weight: 600;
            color: white;
            margin-bottom: 30px;
            padding: 15px 25px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .game-result-word span {
            color: #ffeb3b;
            font-weight: 700;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        
        .return-countdown {
            margin-top: 20px;
        }
        
        /* Voting Result Overlay */
        .voting-result-window {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 50%, #96ceb4 100%);
            border-radius: 25px;
            padding: 40px 50px;
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.4);
            text-align: center;
            max-width: 600px;
            width: 90%;
            transform: scale(0.8);
            transition: transform 0.3s ease;
            border: 3px solid rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
        }
        
        .countdown-overlay.show .voting-result-window {
            transform: scale(1);
        }
        
        .voting-result-icon {
            font-size: 3.5em;
            margin-bottom: 15px;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            animation: resultIconPulse 2s ease-in-out infinite;
        }
        
        .voting-result-title {
            font-size: 2.2em;
            font-weight: 700;
            color: white;
            margin-bottom: 25px;
            text-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
        }
        
        .voting-result-content {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .voting-result-content h3 {
            font-size: 1.6em;
            font-weight: 600;
            color: white;
            margin-bottom: 15px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .voting-result-content p {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.9);
            margin: 8px 0;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .voting-result-content strong {
            color: #fff;
            font-weight: 600;
        }
        
        .voting-countdown {
            margin-top: 15px;
        }
        
        .voting-countdown p {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.9);
            margin: 10px 0;
        }
        
        /* Different colors for different voting results */
        .voting-result-window.continue-game {
            background: linear-gradient(135deg, #4ecdc4 0%, #44a08d 50%, #96ceb4 100%);
        }
        
        .voting-result-window.player-eliminated {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 50%, #d35400 100%);
        }
        
        .voting-result-window.tied-vote {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 50%, #663399 100%);
        }
        
        .countdown-bar-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .countdown-bar {
            height: 100%;
            background: linear-gradient(90deg, #4ecdc4, #44a08d);
            border-radius: 4px;
            transition: width 0.1s linear;
            width: 100%;
        }
        
        .return-countdown p {
            font-size: 1.1em;
            color: rgba(255, 255, 255, 0.9);
            margin-bottom: 15px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .return-btn {
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }
        
        .return-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, #5fd6cc, #4bb3a5);
        }
        
        @keyframes resultIconPulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }
        
        .countdown-title {
            font-size: 2.5em;
            font-weight: 500;
            color: white;
            margin-bottom: 50px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .countdown-circle {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 3px solid rgba(255, 255, 255, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto;
            position: relative;
            overflow: hidden;
        }
        
        .countdown-circle::before {
            content: '';
            position: absolute;
            top: -3px;
            left: -3px;
            right: -3px;
            bottom: -3px;
            border-radius: 50%;
            background: conic-gradient(
                from 0deg,
                rgba(255, 255, 255, 0.8) 0deg,
                rgba(255, 255, 255, 0.3) 72deg,
                rgba(255, 255, 255, 0.1) 360deg
            );
            animation: spinCircle 5s linear infinite;
            z-index: -1;
        }
        
        .countdown-number {
            font-size: 4.5em;
            font-weight: 600;
            color: white;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            animation: countdownPulse 1s ease infinite;
        }
        
        .word-display {
            text-align: center;
            margin-top: 20px;
        }
        
        .word-title {
            font-size: 1.8em;
            font-weight: 500;
            color: white;
            margin-bottom: 20px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .word-text {
            font-size: 2.5em;
            font-weight: 700;
            color: white;
            background: rgba(255, 255, 255, 0.15);
            padding: 20px 30px;
            border-radius: 15px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            animation: wordPulse 0.5s ease;
            display: inline-block;
            min-width: 200px;
        }
        
        .word-text.imposter {
            background: rgba(255, 107, 107, 0.3);
            border-color: rgba(255, 107, 107, 0.5);
            color: #ffdddd;
        }
        
        @keyframes countdownPulse {
            0% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.05);
            }
            100% {
                transform: scale(1);
            }
        }
        
        @keyframes wordPulse {
            0% {
                transform: scale(0.8);
                opacity: 0;
            }
            100% {
                transform: scale(1);
                opacity: 1;
            }
        }
        
        @keyframes spinCircle {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        
        @media (max-width: 768px) {
            .countdown-window {
                padding: 45px 50px;
                max-width: 500px;
            }
            
            .countdown-title {
                font-size: 2em;
                margin-bottom: 35px;
            }
            
            .countdown-circle {
                width: 160px;
                height: 160px;
            }
            
            .countdown-number {
                font-size: 3.5em;
            }
            
            /* Game Finished Overlay Mobile */
            .game-finished-window {
                padding: 35px 40px;
                max-width: 500px;
            }
            
            .game-result-icon {
                font-size: 3.5em;
                margin-bottom: 15px;
            }
            
            .game-result-title {
                font-size: 2.2em;
                margin-bottom: 20px;
            }
            
            .game-result-content {
                padding: 20px;
                margin-bottom: 20px;
            }
            
            .game-result-content h3 {
                font-size: 1.4em;
                margin-bottom: 12px;
            }
            
            .game-result-content p {
                font-size: 1em;
                margin: 6px 0;
            }
            
            .game-result-word {
                font-size: 1.2em;
                padding: 12px 20px;
                margin-bottom: 25px;
            }
            
            .return-countdown p {
                font-size: 1em;
            }
            
            .return-btn {
                padding: 10px 20px;
                font-size: 0.9em;
            }
        }
        
        /* Avatar System Styles */
        .avatar-preview-section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }
        
        .avatar-container {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 60px;
            margin: 0 auto;
        }
        
        .avatar-container.large {
            width: 120px;
            height: 120px;
        }
        
        .game-player-item .avatar-container {
            width: 35px;
            height: 35px;
            flex-shrink: 0;
            margin-right: 0;
        }
        
        .game-player-item .player-name {
            flex: 1;
            text-align: left;
            margin-left: 0;
        }
        
        .avatar-container img {
            width: 100%;
            height: 100%;
            border-radius: 0;
            object-fit: cover;
        }
        
        .avatar-frame {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            border-radius: 0;
            pointer-events: none;
            z-index: 2;
            object-fit: cover;
        }
        
        /* Avatar Selector 3-Column Layout */
        .avatar-selector-container {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            padding: 25px;
            margin: 20px auto;
            max-width: 1600px;
            width: 99%;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            box-sizing: border-box;
        }
        
        .avatar-selector-container h2 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2em;
        }
        
        .avatar-selector-layout {
            display: grid;
            grid-template-columns: 1fr 220px 1fr;
            gap: 25px;
            min-height: 400px;
            max-width: 100%;
            overflow: hidden;
        }
        
        .avatar-column, .preview-column, .frame-column {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            min-width: 0;
            overflow: hidden;
            max-width: 100%;
        }
        
        .avatar-column h3, .preview-column h3, .frame-column h3 {
            color: white;
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
        }
        
        .preview-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
        }
        
        .preview-column .avatar-container {
            margin: 20px 0;
        }
        
        .avatar-preview {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .avatar-type-buttons {
            display: flex;
            flex-direction: row;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .avatar-type-btn {
            padding: 8px 15px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.7em;
            font-weight: 500;
            min-width: 80px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .avatar-type-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        .avatar-type-btn.active {
            background: linear-gradient(135deg, #6b73ff 0%, #9d50bb 100%);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .avatar-grid, .frame-grid {
            display: grid;
            gap: 8px;
            margin: 15px 0;
            justify-items: center;
            width: 100%;
            padding: 5px;
        }
        
        .avatar-grid {
            grid-template-columns: repeat(5, 1fr);
            max-width: 100%;
        }
        
        .frame-grid {
            grid-template-columns: repeat(5, 1fr);
            max-width: 100%;
        }
        
        .avatar-option, .frame-option {
            position: relative;
            width: 50px;
            height: 50px;
            max-width: 50px;
            max-height: 50px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(255, 255, 255, 0.05);
            flex-shrink: 0;
            box-sizing: border-box;
        }
        
        .avatar-option img {
            width: 100%;
            height: 100%;
            border-radius: 0;
            object-fit: cover;
        }
        
        .avatar-option:hover, .frame-option:hover {
            transform: scale(1.1);
            border-color: rgba(107, 115, 255, 0.6);
            box-shadow: 0 5px 20px rgba(107, 115, 255, 0.3);
        }
        
        .avatar-option.active, .frame-option.active {
            border-color: #6b73ff;
            background: rgba(107, 115, 255, 0.2);
            box-shadow: 0 0 20px rgba(107, 115, 255, 0.4);
        }
        
        .frame-option span {
            font-size: 12px;
            text-align: center;
            color: white;
        }
        
        .frame-option img {
            width: 100%;
            height: 100%;
            border-radius: 0;
            object-fit: cover;
        }
        
        .vip-locked {
            opacity: 0.6;
            position: relative;
        }
        
        .vip-locked:hover {
            opacity: 0.8;
        }
        
        .vip-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            color: #000;
            font-size: 8px;
            font-weight: bold;
            padding: 2px 4px;
            border-radius: 3px;
            z-index: 3;
            pointer-events: none;
        }
        
        .avatar-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }
        
        /* Player list avatar integration */
        .player-item {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            margin-bottom: 10px;
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .player-item:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(107, 115, 255, 0.3);
        }
        
        .player-avatar {
            flex-shrink: 0;
        }
        
        .player-info {
            flex-grow: 1;
        }
        
        .player-name {
            font-weight: bold;
            color: white;
        }
        
        .host-badge {
            background: linear-gradient(135deg, #ffd700, #ffed4a);
            color: #333;
            padding: 2px 8px;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: bold;
            margin-left: 10px;
        }
        
        /* Responsive Avatar Selector */
        @media (max-width: 600px) {
            .avatar-selector-layout {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .preview-column {
                order: -1;
            }
            
            .avatar-selector-container {
                margin: 10px;
                padding: 20px;
                width: calc(100% - 20px);
                max-width: none;
            }
            
            .avatar-type-buttons {
                flex-direction: row;
                justify-content: center;
                flex-wrap: wrap;
            }
            
            .avatar-grid, .frame-grid {
                grid-template-columns: repeat(4, 1fr);
                gap: 6px;
            }
            
            .avatar-option, .frame-option {
                width: 45px;
                height: 45px;
                max-width: 45px;
                max-height: 45px;
            }
        }
        
        @media (max-width: 480px) {
            .avatar-grid, .frame-grid {
                grid-template-columns: repeat(3, 1fr);
                gap: 6px;
            }
            
            .avatar-option, .frame-option {
                width: 40px;
                height: 40px;
                max-width: 40px;
                max-height: 40px;
            }
        }
    </style>
</head>
<body>
    <!-- Countdown Overlay -->
    <div id="countdown-overlay" class="countdown-overlay">
        <div class="countdown-window">
            <div class="countdown-title" id="countdown-title">Spiel startet gleich...</div>
            <div class="countdown-circle" id="countdown-circle">
                <div class="countdown-number" id="countdown-number">5</div>
            </div>
            <div class="word-display" id="word-display" style="display: none;">
                <div class="word-title" id="word-title">Dein Wort:</div>
                <div class="word-text" id="word-text"></div>
            </div>
        </div>
    </div>

    <!-- User Profile (Top Right) -->
    <div id="user-profile" class="user-profile hidden">
        <div class="profile-info">
            <span id="username-display">Benutzer</span>
            <div class="profile-stats">
                üéÆ <span id="games-played">0</span> | üèÜ <span id="wins">0</span> | üíî <span id="losses">0</span>
            </div>
        </div>
        <div class="profile-actions">
            <button onclick="showStats()" class="profile-btn">üìä Stats</button>
            <button onclick="logout()" class="profile-btn logout-btn">üö™ Logout</button>
        </div>
    </div>

    <div class="container">
        <div class="logo-container">
            <img src="/images/titel.png" alt="Imposter by hAiQ" class="game-logo">
        </div>
        
        <!-- Login/Register Screen -->
        <div id="auth-screen" class="card">
            <h2>Willkommen!</h2>
            <p>Melde dich an oder registriere dich, um zu spielen</p>
            
            <div id="login-form">
                <h3>Anmelden</h3>
                <input type="text" id="login-username" placeholder="Benutzername" maxlength="20">
                <input type="password" id="login-password" placeholder="Passwort">
                <button onclick="loginUser()" class="primary-btn">Anmelden</button>
                <p><a href="#" onclick="showRegisterForm()">Noch kein Account? Registrieren</a></p>
            </div>
            
            <div id="register-form" class="hidden">
                <h3>Registrieren</h3>
                <input type="text" id="register-username" placeholder="Benutzername (mind. 3 Zeichen, nur Buchstaben/Zahlen)" maxlength="20">
                <input type="password" id="register-password" placeholder="Passwort (mind. 3 Zeichen)">
                <button onclick="registerUser()" class="primary-btn">Registrieren</button>
                <p><a href="#" onclick="showLoginForm()">Bereits registriert? Anmelden</a></p>
            </div>
        </div>

        <!-- Main Menu -->
        <div id="main-menu" class="card hidden">
            <h2>Willkommen!</h2>
            
            <!-- Avatar Preview -->
            <div class="avatar-preview-section">
                <div class="current-avatar-display">
                    <div id="current-avatar-container" class="avatar-container">
                        <img id="current-avatar-img" src="/images/avatare/standard.png" alt="Aktueller Avatar">
                        <img id="current-frame-img" class="avatar-frame hidden" alt="Avatar-Rahmen">
                    </div>
                </div>
                <button onclick="showAvatarSelector()" class="secondary-btn">Avatar √§ndern</button>
            </div>
            
            <button onclick="showCreateMatch()">Neues Spiel erstellen</button>
            <button onclick="showJoinMatch()">Spiel beitreten</button>
            <button onclick="showLobby()">√ñffentliche Spiele durchsuchen</button>
        </div>
        
        <!-- Lobby Screen -->
        <div id="lobby-screen" class="card hidden">
            <h2>üéÆ √ñffentliche Spiele</h2>
            <p>Tritt einem laufenden Spiel bei oder warte auf neue Spiele:</p>
            <div id="lobby-matches"></div>
            <button onclick="showMainMenu()" class="secondary-btn">Zur√ºck zum Hauptmen√º</button>
        </div>
        
        <!-- Create Match -->
        <div id="create-match" class="card hidden">
            <h2>Neues Spiel erstellen</h2>
            <label>
                <input type="checkbox" id="private-match"> Privates Spiel (mit Passwort)
            </label>
            <input type="password" id="match-password" placeholder="Passwort (optional)" class="hidden">
            <button onclick="createMatch()" class="primary-btn">Spiel erstellen</button>
            <button onclick="showMainMenu()">Zur√ºck</button>
        </div>
        
        <!-- Avatar Selector -->
        <div id="avatar-selector" class="avatar-selector-container hidden">
            <h2>üé® Avatar ausw√§hlen</h2>
            
            <div class="avatar-selector-layout">
                <!-- Left Column: Avatar Selection -->
                <div class="avatar-column">
                    <h3>Avatar w√§hlen</h3>
                    <div class="avatar-type-buttons">
                        <button id="btn-standard" class="avatar-type-btn active" onclick="selectAvatarType('standard')">Standard</button>
                        <button id="btn-m√§nnlich" class="avatar-type-btn" onclick="selectAvatarType('m√§nnlich')">M√§nnlich</button>
                        <button id="btn-weiblich" class="avatar-type-btn" onclick="selectAvatarType('weiblich')">Weiblich</button>
                    </div>
                    <div id="avatar-grid" class="avatar-grid">
                        <!-- Will be populated dynamically -->
                    </div>
                </div>
                
                <!-- Center Column: Preview -->
                <div class="preview-column">
                    <h3>Vorschau</h3>
                    <div class="avatar-container large">
                        <img id="preview-avatar-img" src="/images/avatare/standard.png" alt="Avatar-Vorschau">
                        <img id="preview-frame-img" class="avatar-frame hidden" alt="Rahmen-Vorschau">
                    </div>
                </div>
                
                <!-- Right Column: Frame Selection -->
                <div class="frame-column">
                    <h3>Rahmen (Optional)</h3>
                    <div id="frame-grid" class="frame-grid">
                        <div class="frame-option active" onclick="selectFrame(0)">
                            <span>Kein Rahmen</span>
                        </div>
                        <!-- Frames 1-7 -->
                    </div>
                </div>
            </div>
            
            <div class="avatar-actions">
                <button onclick="saveAvatar()" class="primary-btn">Avatar speichern</button>
                <button onclick="showMainMenu()">Abbrechen</button>
            </div>
        </div>
        
        <!-- Stats Screen -->
        <div id="stats-screen" class="card hidden">
            <h2>üèÜ Deine Statistiken</h2>
            <div class="stats-grid">
                <div class="stat-item">
                    <h3>üéÆ Spiele gespielt</h3>
                    <p id="stats-games-played">0</p>
                </div>
                <div class="stat-item">
                    <h3>üèÜ Siege</h3>
                    <p id="stats-wins">0</p>
                </div>
                <div class="stat-item">
                    <h3>üíî Niederlagen</h3>
                    <p id="stats-losses">0</p>
                </div>
                <div class="stat-item">
                    <h3>üìä Siegesrate</h3>
                    <p id="stats-winrate">0%</p>
                </div>
                <div class="stat-item">
                    <h3>üé≠ Imposter Siege</h3>
                    <p id="stats-imposter-wins">0</p>
                </div>
                <div class="stat-item">
                    <h3>üéØ W√∂rter als Imposter erraten</h3>
                    <p id="stats-words-guessed">0</p>
                </div>
                <div class="stat-item">
                    <h3>üó≥Ô∏è Stimmen erhalten</h3>
                    <p id="stats-votes-received">0</p>
                </div>
                <div class="stat-item">
                    <h3>‚úÖ Richtige Stimmen</h3>
                    <p id="stats-correct-votes">0</p>
                </div>
                <div class="stat-item">
                    <h3>üìÖ Registriert seit</h3>
                    <p id="stats-created-at">-</p>
                </div>
            </div>
            <button onclick="showMainMenu()" class="secondary-btn">Zur√ºck zum Hauptmen√º</button>
        </div>
        
        <!-- Join Match -->
        <div id="join-match" class="card hidden">
            <h2>Spiel beitreten</h2>
            <input type="text" id="match-id" placeholder="Spiel-ID" maxlength="6">
            <input type="password" id="join-password" placeholder="Passwort (falls erforderlich)">
            <button onclick="joinMatch()" class="primary-btn">Beitreten</button>
            <button onclick="showMainMenu()">Zur√ºck</button>
        </div>
        
        <!-- Waiting Room -->
        <div id="waiting-room" class="card hidden">
            <h2>Warteraum</h2>
            <div class="game-info">
                <p>Spiel-ID: <strong id="current-match-id"></strong> 
                   <button onclick="copyMatchLink()" class="copy-btn" title="Link kopieren">üìã</button>
                </p>
                <p>Mindestens 4 Spieler ben√∂tigt zum Starten</p>
            </div>
            <div class="players-list" id="players-list"></div>
            <button id="start-game-btn" onclick="startGame()" class="primary-btn hidden">Spiel starten</button>
            <button onclick="leaveMatch()" class="danger">Spiel verlassen</button>
        </div>

        <!-- Players List (positioned at screen edge, outside of game card) -->
        <div id="game-players-list" class="game-players-list">
            <h4>Spieler:</h4>
            <div id="game-players-display"></div>
        </div>

        <!-- Game Screen -->
        <div id="game-screen" class="card game-screen hidden">
            <button id="back-to-menu-btn" class="back-to-menu-btn" onclick="returnToMainMenu()">
                ‚Üê Men√º
            </button>
            
            <div class="game-info" id="game-info">
                <p>Runde: <span id="current-round">1</span></p>
                <p>Aktueller Spieler: <span id="current-player"></span></p>
            </div>
            
            <!-- Voting Section (hidden by default, shown during voting) -->
            <div id="voting-section" class="hidden">
                <h3>Abstimmung</h3>
                <div id="continue-voting-inline" class="hidden">
                    <p>Was m√∂chtet ihr machen?</p>
                    <div class="vote-options">
                        <button onclick="vote('continue')">Weiterspielen</button>
                        <button onclick="vote('guess')">Imposter erraten</button>
                    </div>
                </div>
                
                <div id="imposter-voting-inline" class="hidden">
                    <p>Wer ist der Imposter?</p>
                    <div class="player-vote-grid" id="vote-players-inline"></div>
                </div>
                
                <div id="voting-status-inline">
                    <p>Warten auf alle Stimmen...</p>
                </div>
            </div>
            
            <div class="word-display">
                Dein Wort: <span id="player-word"></span>
            </div>
            
            <div id="word-input-section" class="hidden">
                <input type="text" id="word-input" placeholder="Schreibe ein Wort, das zu deinem Begriff passt..." maxlength="30">
                <button onclick="submitWord()" class="primary-btn">Wort abschicken</button>
            </div>
            
            <div class="words-list" id="words-list"></div>
        </div>
        
        <!-- Voting Screen -->
        <div id="voting-screen" class="card voting-screen hidden">
            <button id="back-to-menu-btn-voting" class="back-to-menu-btn" onclick="returnToMainMenu()">
                ‚Üê Men√º
            </button>
            
            <h2>Abstimmung</h2>
            <div id="continue-voting" class="hidden">
                <p>Was m√∂chtet ihr machen?</p>
                <div class="vote-options">
                    <button onclick="vote('continue')">Weiterspielen</button>
                    <button onclick="vote('guess')">Imposter erraten</button>
                </div>
            </div>
            
            <div id="imposter-voting" class="hidden">
                <p>Wer ist der Imposter?</p>
                <div class="player-vote-grid" id="vote-players"></div>
            </div>
            
            <div class="game-info">
                <div id="voting-status">
                    <p>Warten auf alle Stimmen...</p>
                </div>
            </div>
        </div>
        
        <!-- Game Finished Overlay -->
        <div id="game-finished-overlay" class="countdown-overlay">
            <div class="game-finished-window">
                <div class="game-result-icon" id="game-result-icon">üé≠</div>
                <div class="game-result-title" id="game-result-title">Spiel beendet!</div>
                <div class="game-result-content" id="game-result-content">
                    <!-- Dynamic content will be inserted here -->
                </div>
                <div class="game-result-word" id="game-result-word">
                    Das Wort war: <span id="result-word"></span>
                </div>
                <div class="return-countdown">
                    <div class="countdown-bar-container">
                        <div class="countdown-bar" id="return-countdown-bar"></div>
                    </div>
                    <p>Automatische R√ºckkehr zur Lobby in <span id="return-timer">15</span> Sekunden</p>
                    <button onclick="returnToLobbyManually()" class="return-btn">Sofort zur Lobby</button>
                </div>
            </div>
        </div>

        <!-- Voting Result Overlay -->
        <div id="voting-result-overlay" class="countdown-overlay">
            <div class="voting-result-window">
                <div class="voting-result-icon" id="voting-result-icon">üìä</div>
                <div class="voting-result-title" id="voting-result-title">Abstimmungsergebnis</div>
                <div class="voting-result-content" id="voting-result-content">
                    <!-- Dynamic content will be inserted here -->
                </div>
                <div class="voting-countdown">
                    <div class="countdown-bar-container">
                        <div class="countdown-bar" id="voting-countdown-bar"></div>
                    </div>
                    <p>Weiter in <span id="voting-timer">5</span> Sekunden</p>
                </div>
            </div>
        </div>

        <!-- Game Finished (Old Version - Keep as fallback) -->
        <div id="game-finished" class="card hidden">
            <h2>Spiel beendet!</h2>
            <div id="game-result"></div>
            <p style="margin: 20px 0; color: #ccc;">
                Ihr werdet automatisch in 5 Sekunden zur Lobby zur√ºckgebracht...
            </p>
            <button onclick="returnToLobbyManually()" class="primary-btn">Sofort zur Lobby</button>
            <button onclick="showMainMenu()">Hauptmen√º</button>
        </div>

        <!-- Error Messages -->
        <div id="error-message" class="error hidden"></div>
        <div id="success-message" class="success hidden"></div>
    </div>

    <!-- Messages Container (fixed position) -->
    <div id="messages-container">
        <div id="error-message-fixed" class="error-fixed hidden"></div>
        <div id="success-message-fixed" class="success-fixed hidden"></div>
    </div>    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        
        let currentMatchId = null;
        let isHost = false;
        let playerWord = null;
        let isImposter = false;
        let isSpectator = false;
        let hasVoted = false; // Track if user has already voted in current voting round
        let currentVotingType = null; // Track current voting type to detect changes
        let currentPlayerName = null;
        let myPlayerName = null;
        let currentUser = null;
        let currentUserVIP = false;
        let currentPlayers = []; // Store current players for game screen
        
        // Avatar System Variables
        let selectedAvatarType = 'standard';
        let selectedAvatarId = 0;
        let selectedFrame = 0;
        let currentUserAvatar = { type: 'standard', id: 0, frame: 0 };
        
        // URL Routing System
        function updateURL(matchId = null) {
            const currentPath = window.location.pathname;
            if (matchId) {
                const newPath = `/match/${matchId}`;
                if (currentPath !== newPath) {
                    window.history.pushState({ matchId: matchId }, '', newPath);
                }
            } else {
                if (currentPath !== '/' && currentPath !== '') {
                    window.history.pushState({}, '', '/');
                }
            }
        }
        
        function getMatchIdFromURL() {
            const path = window.location.pathname;
            const match = path.match(/^\/match\/([A-Z0-9]+)$/);
            return match ? match[1] : null;
        }
        
        function handleURLNavigation() {
            const matchId = getMatchIdFromURL();
            if (matchId && matchId !== currentMatchId) {
                // Try to join the match from URL
                if (currentUser) {
                    console.log('Attempting to join match from URL:', matchId);
                    joinMatchById(matchId);
                } else {
                    // Store match ID to join after login
                    sessionStorage.setItem('pendingMatchId', matchId);
                }
            } else if (!matchId && currentMatchId) {
                // User navigated back to home, leave current match
                leaveMatch();
            }
        }
        
        // Handle browser back/forward navigation
        window.addEventListener('popstate', function(event) {
            handleURLNavigation();
        });
        
        // Check if user is logged in on page load
        window.onload = function() {
            const savedUser = localStorage.getItem('imposterUser');
            if (savedUser) {
                currentUser = JSON.parse(savedUser);
                currentUserVIP = currentUser.vip || false;
                myPlayerName = currentUser.username;
                
                // Load avatar data
                if (currentUser.avatar) {
                    currentUserAvatar = currentUser.avatar;
                } else {
                    // Fallback for users without avatar data
                    currentUserAvatar = { type: 'standard', id: 0, frame: 0 };
                }
                
                // Check for saved spectator status
                const savedSpectator = localStorage.getItem('imposterSpectator');
                if (savedSpectator === 'true') {
                    isSpectator = true;
                    console.log('üé≠ RESTORE: Spectator status restored from localStorage');
                }
                
                // Automatically login with socket to refresh user data
                socket.emit('user_login', { 
                    username: currentUser.username, 
                    password: localStorage.getItem('imposterPassword') || '' 
                });
                
                // Refresh user data from server to get latest VIP status
                refreshUserData();
                
                showUserInterface();
                
                // Check URL for match ID after user is set
                setTimeout(() => {
                    handleURLNavigation();
                }, 100);
            } else {
                showAuthScreen();
                // Still check URL in case user needs to login first
                handleURLNavigation();
            }
        };
        
        // Auth Functions
        function showAuthScreen() {
            hideAllScreens();
            document.getElementById('user-profile').classList.add('hidden');
            document.getElementById('auth-screen').classList.remove('hidden');
        }
        
        function showLoginForm() {
            document.getElementById('login-form').classList.remove('hidden');
            document.getElementById('register-form').classList.add('hidden');
        }
        
        function showRegisterForm() {
            document.getElementById('register-form').classList.remove('hidden');
            document.getElementById('login-form').classList.add('hidden');
        }
        
        async function registerUser() {
            const username = document.getElementById('register-username').value.trim();
            const password = document.getElementById('register-password').value;
            
            if (!username || !password) {
                showError('Bitte f√ºlle alle Felder aus');
                return;
            }
            
            try {
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, password })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.success) {
                    showSuccess(result.message);
                    showLoginForm();
                    document.getElementById('login-username').value = username;
                } else {
                    showError(result.message);
                }
            } catch (error) {
                console.error('Registration error:', error);
                showError('Registrierung fehlgeschlagen: ' + error.message);
            }
        }
        
        async function loginUser() {
            const username = document.getElementById('login-username').value.trim();
            const password = document.getElementById('login-password').value;
            
            if (!username || !password) {
                showError('Bitte f√ºlle alle Felder aus');
                return;
            }
            
            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ username, password })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentUser = result.user;
                    currentUserVIP = result.user.vip || false;
                    myPlayerName = result.user.username;
                    localStorage.setItem('imposterUser', JSON.stringify(result.user));
                    localStorage.setItem('imposterPassword', password); // Store password for socket login
                    
                    // Inform socket about login
                    socket.emit('user_login', { 
                        username: username, 
                        password: password 
                    });
                    
                    showUserInterface();
                } else {
                    showError(result.message);
                }
            } catch (error) {
                showError('Login fehlgeschlagen');
            }
        }
        
        function logout() {
            currentUser = null;
            myPlayerName = null;
            localStorage.removeItem('imposterUser');
            localStorage.removeItem('imposterPassword');
            document.getElementById('user-profile').classList.add('hidden');
            showAuthScreen();
        }
        
        function showUserInterface() {
            hideAllScreens();
            document.getElementById('auth-screen').classList.add('hidden');
            document.getElementById('main-menu').classList.remove('hidden');
            document.getElementById('user-profile').classList.remove('hidden');
            
            // Update user profile display
            document.getElementById('username-display').textContent = currentUser.username;
            updateStatsDisplay(currentUser.stats);
            
            // Load and display current user avatar
            if (currentUser.avatar) {
                currentUserAvatar = currentUser.avatar;
                updateCurrentAvatarDisplay();
            }
        }
        
        // Refresh user data from server
        async function refreshUserData() {
            if (!currentUser) return;
            
            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({ 
                        username: currentUser.username, 
                        password: localStorage.getItem('imposterPassword') || '' 
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    currentUser = result.user;
                    currentUserVIP = result.user.vip || false;
                    localStorage.setItem('imposterUser', JSON.stringify(result.user));
                    
                    // Update avatar data if available
                    if (result.user.avatar) {
                        currentUserAvatar = result.user.avatar;
                    }
                    
                    console.log('User data refreshed, VIP status:', currentUserVIP);
                }
            } catch (error) {
                console.error('Error refreshing user data:', error);
            }
        }
        
        // Avatar System Functions
        function showAvatarSelector() {
            hideAllScreens();
            document.getElementById('avatar-selector').classList.remove('hidden');
            
            // Initialize avatar selector with current user avatar
            selectedAvatarType = currentUserAvatar.type;
            selectedAvatarId = currentUserAvatar.id;
            selectedFrame = currentUserAvatar.frame;
            
            // Update UI
            updateAvatarTypeButtons();
            loadAvatarGrid();
            loadFrameGrid();
            updateAvatarPreview();
        }
        
        function selectAvatarType(type) {
            selectedAvatarType = type;
            selectedAvatarId = type === 'standard' ? 0 : 1; // Default to first avatar of selected type
            updateAvatarTypeButtons();
            loadAvatarGrid();
            updateAvatarPreview();
        }
        
        function updateAvatarTypeButtons() {
            const buttons = document.querySelectorAll('.avatar-type-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.id === `btn-${selectedAvatarType}`) {
                    btn.classList.add('active');
                }
            });
        }
        
        function loadAvatarGrid() {
            const grid = document.getElementById('avatar-grid');
            grid.innerHTML = '';
            
            if (selectedAvatarType === 'standard') {
                // Standard avatar (only one option)
                const option = document.createElement('div');
                option.className = selectedAvatarId === 0 ? 'avatar-option active' : 'avatar-option';
                option.innerHTML = '<img src="/images/avatare/standard.png" alt="Standard Avatar">';
                option.onclick = () => selectAvatar(0);
                grid.appendChild(option);
            } else {
                // Gender-specific avatars (1-20)
                for (let i = 1; i <= 20; i++) {
                    const option = document.createElement('div');
                    option.className = selectedAvatarId === i ? 'avatar-option active' : 'avatar-option';
                    option.innerHTML = `<img src="/images/avatare/${selectedAvatarType}/${i}.png" alt="Avatar ${i}">`;
                    option.onclick = () => selectAvatar(i);
                    grid.appendChild(option);
                }
            }
        }
        
        function loadFrameGrid() {
            console.log('Loading frame grid. Current VIP status:', currentUserVIP);
            const grid = document.getElementById('frame-grid');
            grid.innerHTML = '';
            
            // No frame option
            const noFrame = document.createElement('div');
            noFrame.className = selectedFrame === 0 ? 'frame-option active' : 'frame-option';
            noFrame.innerHTML = '<span>Kein Rahmen</span>';
            noFrame.onclick = () => selectFrame(0);
            grid.appendChild(noFrame);
            
            // Frame options 1-7
            for (let i = 1; i <= 7; i++) {
                const option = document.createElement('div');
                option.className = selectedFrame === i ? 'frame-option active' : 'frame-option';
                option.innerHTML = `<img src="/images/avatare/rahmen/${i}.png" alt="Rahmen ${i}">`;
                option.onclick = () => selectFrame(i);
                grid.appendChild(option);
            }
            
            // Rainbow frame (VIP only)
            const rainbowFrame = document.createElement('div');
            rainbowFrame.className = selectedFrame === 'rainbow' ? 'frame-option active' : 'frame-option';
            if (!currentUserVIP) {
                rainbowFrame.classList.add('vip-locked');
            }
            rainbowFrame.innerHTML = `<img src="/images/avatare/rahmen/admin/rainbow.gif" alt="Rainbow Rahmen (VIP)"><div class="vip-badge">VIP</div>`;
            rainbowFrame.onclick = () => {
                console.log('Rainbow frame clicked. Current VIP status:', currentUserVIP);
                if (currentUserVIP) {
                    selectFrame('rainbow');
                } else {
                    showError('Dieser Rahmen ist nur f√ºr VIP-Benutzer verf√ºgbar!');
                }
            };
            grid.appendChild(rainbowFrame);
        }
        
        function selectAvatar(id) {
            selectedAvatarId = id;
            loadAvatarGrid(); // Refresh grid to update active state
            updateAvatarPreview();
        }
        
        function selectFrame(frameId) {
            selectedFrame = frameId;
            loadFrameGrid(); // Refresh grid to update active state
            updateAvatarPreview();
        }
        
        function updateAvatarPreview() {
            const avatarImg = document.getElementById('preview-avatar-img');
            const frameImg = document.getElementById('preview-frame-img');
            
            // Update avatar image
            if (selectedAvatarType === 'standard') {
                avatarImg.src = '/images/avatare/standard.png';
            } else {
                avatarImg.src = `/images/avatare/${selectedAvatarType}/${selectedAvatarId}.png`;
            }
            
            // Update frame
            if (selectedFrame === 0) {
                frameImg.classList.add('hidden');
            } else if (selectedFrame === 'rainbow') {
                frameImg.src = '/images/avatare/rahmen/admin/rainbow.gif';
                frameImg.classList.remove('hidden');
            } else {
                frameImg.src = `/images/avatare/rahmen/${selectedFrame}.png`;
                frameImg.classList.remove('hidden');
            }
        }
        
        function updateCurrentAvatarDisplay() {
            const avatarImg = document.getElementById('current-avatar-img');
            const frameImg = document.getElementById('current-frame-img');
            
            // Update avatar image
            if (currentUserAvatar.type === 'standard') {
                avatarImg.src = '/images/avatare/standard.png';
            } else {
                avatarImg.src = `/images/avatare/${currentUserAvatar.type}/${currentUserAvatar.id}.png`;
            }
            
            // Update frame
            if (currentUserAvatar.frame === 0) {
                frameImg.classList.add('hidden');
            } else if (currentUserAvatar.frame === 'rainbow') {
                frameImg.src = '/images/avatare/rahmen/admin/rainbow.gif';
                frameImg.classList.remove('hidden');
            } else {
                frameImg.src = `/images/avatare/rahmen/${currentUserAvatar.frame}.png`;
                frameImg.classList.remove('hidden');
            }
        }
        
        async function saveAvatar() {
            try {
                const response = await fetch('/api/update-avatar', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        username: currentUser.username,
                        avatar: {
                            type: selectedAvatarType,
                            id: selectedAvatarId,
                            frame: selectedFrame
                        }
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Update current user avatar
                    currentUserAvatar = result.avatar;
                    currentUser.avatar = result.avatar;
                    
                    // Update localStorage
                    localStorage.setItem('imposterUser', JSON.stringify(currentUser));
                    
                    // Update display
                    updateCurrentAvatarDisplay();
                    
                    showSuccess('Avatar erfolgreich gespeichert!');
                    setTimeout(() => {
                        showMainMenu();
                    }, 1500);
                } else {
                    showError(result.message);
                }
            } catch (error) {
                showError('Fehler beim Speichern des Avatars');
            }
        }
        
        function getAvatarImagePath(avatar) {
            // Fallback f√ºr undefinierte oder null avatars
            if (!avatar) {
                return '/images/avatare/standard.png';
            }
            
            if (avatar.type === 'standard' || !avatar.type) {
                return '/images/avatare/standard.png';
            }
            
            // Pr√ºfe auf g√ºltige Avatar-ID
            if (!avatar.id || avatar.id < 1 || avatar.id > 20) {
                console.warn('Invalid avatar ID:', avatar.id, 'for type:', avatar.type, 'falling back to standard');
                return '/images/avatare/standard.png';
            }
            
            return `/images/avatare/${avatar.type}/${avatar.id}.png`;
        }
        
        function getFrameImagePath(avatar) {
            if (!avatar || !avatar.frame || avatar.frame === 0) {
                return null;
            }
            if (avatar.frame === 'rainbow') {
                return '/images/avatare/rahmen/admin/rainbow.gif';
            }
            
            // Pr√ºfe auf g√ºltige Frame-ID
            if (avatar.frame < 1 || avatar.frame > 7) {
                console.warn('Invalid frame ID:', avatar.frame, 'returning null');
                return null;
            }
            
            return `/images/avatare/rahmen/${avatar.frame}.png`;
        }
        
        function updateStatsDisplay(stats) {
            document.getElementById('games-played').textContent = stats.gamesPlayed;
            document.getElementById('wins').textContent = stats.wins;
            document.getElementById('losses').textContent = stats.losses;
        }
        
        function showStats() {
            hideAllScreens();
            document.getElementById('stats-screen').classList.remove('hidden');
            
            const stats = currentUser.stats;
            document.getElementById('stats-games-played').textContent = stats.gamesPlayed;
            document.getElementById('stats-wins').textContent = stats.wins;
            document.getElementById('stats-losses').textContent = stats.losses;
            document.getElementById('stats-imposter-wins').textContent = stats.imposterWins;
            document.getElementById('stats-words-guessed').textContent = stats.wordsGuessedAsImposter;
            document.getElementById('stats-votes-received').textContent = stats.totalVotesReceived;
            document.getElementById('stats-correct-votes').textContent = stats.correctVotes;
            
            const winrate = stats.gamesPlayed > 0 ? ((stats.wins / stats.gamesPlayed) * 100).toFixed(1) : 0;
            document.getElementById('stats-winrate').textContent = winrate + '%';
            
            const createdDate = new Date(stats.createdAt).toLocaleDateString('de-DE');
            document.getElementById('stats-created-at').textContent = createdDate;
        }
        
        // UI Functions
        function showMainMenu() {
            hideAllScreens();
            document.getElementById('main-menu').classList.remove('hidden');
            // Show user profile if logged in
            if (currentUser) {
                document.getElementById('user-profile').classList.remove('hidden');
            }
        }
        
        function showCreateMatch() {
            hideAllScreens();
            document.getElementById('create-match').classList.remove('hidden');
        }
        
        function showJoinMatch() {
            hideAllScreens();
            document.getElementById('join-match').classList.remove('hidden');
        }
        
        function showLobby() {
            hideAllScreens();
            document.getElementById('lobby-screen').classList.remove('hidden');
            // Show user profile if logged in
            if (currentUser) {
                document.getElementById('user-profile').classList.remove('hidden');
            }
        }
        
        function hideAllScreens() {
            const screens = ['main-menu', 'create-match', 'join-match', 'lobby-screen', 'waiting-room', 'game-screen', 'voting-screen', 'game-finished', 'stats-screen', 'avatar-selector'];
            screens.forEach(screen => {
                document.getElementById(screen).classList.add('hidden');
            });
            hideError();
            hideGamePlayersList(); // Hide players list when switching screens
        }
        
        function showGamePlayersList() {
            const playersList = document.getElementById('game-players-list');
            if (playersList) {
                playersList.style.display = 'block';
            }
        }
        
        function hideGamePlayersList() {
            const playersList = document.getElementById('game-players-list');
            if (playersList) {
                playersList.style.display = 'none';
            }
        }
        
        function updateGamePlayersList(players, currentPlayerName = null) {
            console.log('updateGamePlayersList called with:', players.length, 'players, current:', currentPlayerName);
            const playersDisplay = document.getElementById('game-players-display');
            if (!playersDisplay) {
                console.error('game-players-display element not found');
                return;
            }
            
            playersDisplay.innerHTML = '';
            
            if (!players || !Array.isArray(players)) {
                console.warn('No valid players array provided');
                return;
            }
            
            // Update header to show player count
            const header = document.querySelector('.game-players-list h4');
            if (header) {
                header.textContent = `Spieler (${players.length}/8):`;
            }
            
            players.forEach((player, index) => {
                const playerElement = document.createElement('div');
                playerElement.className = 'game-player-item';
                
                // Highlight current player
                if (currentPlayerName && player.name === currentPlayerName) {
                    playerElement.classList.add('current-player');
                }
                
                // Create avatar container
                const avatarContainer = document.createElement('div');
                avatarContainer.className = 'player-avatar avatar-container';
                
                const avatarImg = document.createElement('img');
                avatarImg.src = getAvatarImagePath(player.avatar);
                avatarImg.alt = `${player.name} Avatar`;
                avatarContainer.appendChild(avatarImg);
                
                // Add frame if exists
                if (player.avatar && (player.avatar.frame > 0 || player.avatar.frame === 'rainbow')) {
                    const frameImg = document.createElement('img');
                    frameImg.src = getFrameImagePath(player.avatar);
                    frameImg.className = 'avatar-frame';
                    frameImg.alt = 'Avatar Rahmen';
                    avatarContainer.appendChild(frameImg);
                }
                
                // Create player name element
                const playerName = document.createElement('span');
                playerName.className = 'player-name';
                
                // Mark host
                if (player.isHost) {
                    playerElement.classList.add('host');
                    playerName.textContent = `${player.name} (Host)`;
                } else {
                    playerName.textContent = player.name;
                }
                
                // Assemble player element
                playerElement.appendChild(avatarContainer);
                playerElement.appendChild(playerName);
                
                // Add title attribute for long names (tooltip)
                if (player.name.length > 12) {
                    playerElement.title = player.name;
                }
                
                playersDisplay.appendChild(playerElement);
            });
            
            console.log('Players list updated with', players.length, 'players');
        }
        
        // Test function to show players list
        function testPlayersDisplay() {
            const testPlayers = [
                { name: 'Test1', isHost: true },
                { name: 'Test2', isHost: false },
                { name: 'Test3', isHost: false },
                { name: 'Test4', isHost: false },
                { name: 'Test5', isHost: false },
                { name: 'Test6', isHost: false },
                { name: 'Test7', isHost: false },
                { name: 'Test8', isHost: false }
            ];
            console.log('Showing test players (8 players):', testPlayers);
            updateGamePlayersList(testPlayers, 'Test2');
        }
        
        // Function to test 8 players manually (call from console)
        window.test8Players = function() {
            const eightPlayers = [
                { name: 'PlayerOne', isHost: true },
                { name: 'PlayerTwo', isHost: false },
                { name: 'PlayerThree', isHost: false },
                { name: 'PlayerFour', isHost: false },
                { name: 'PlayerFive', isHost: false },
                { name: 'PlayerSix', isHost: false },
                { name: 'PlayerSeven', isHost: false },
                { name: 'PlayerEight', isHost: false }
            ];
            console.log('Testing 8 players layout:', eightPlayers);
            updateGamePlayersList(eightPlayers, 'PlayerThree');
        };
        
        // Debug function to check if element exists
        function checkPlayersListElement() {
            const element = document.getElementById('game-players-list');
            const display = document.getElementById('game-players-display');
            console.log('Players list element:', element);
            console.log('Players display element:', display);
            if (element) {
                console.log('Element style:', window.getComputedStyle(element));
            }
        }
        
        function updateMatchDisplay(match) {
            if (match.gameState === 'waiting') {
                // Show waiting room
                hideAllScreens();
                document.getElementById('waiting-room').classList.remove('hidden');
                document.getElementById('user-profile').classList.remove('hidden');
                
                // Update waiting room display
                const playersDiv = document.getElementById('waiting-players');
                playersDiv.innerHTML = '';
                
                match.players.forEach(player => {
                    const playerElement = document.createElement('div');
                    playerElement.className = 'player-item';
                    if (player.isHost) {
                        playerElement.innerHTML = `<strong>${player.name}</strong> (Host)`;
                    } else {
                        playerElement.innerHTML = player.name;
                    }
                    playersDiv.appendChild(playerElement);
                });
                
                // Show/hide start button for host
                const startButton = document.getElementById('start-game');
                const isHost = match.players.some(p => p.name === myPlayerName && p.isHost);
                if (isHost) {
                    startButton.style.display = 'block';
                } else {
                    startButton.style.display = 'none';
                }
                
            } else if (match.gameState === 'playing' || match.gameState === 'voting_continue' || match.gameState === 'voting_imposter') {
                // Show game screen
                hideAllScreens();
                document.getElementById('game-screen').classList.remove('hidden');
                document.getElementById('user-profile').classList.remove('hidden');
                
                // Update players list in game screen (top left)
                updateGamePlayersList(match.players, match.currentPlayer);
                
                // Update old players list (if it exists)
                const playersDiv = document.getElementById('game-players');
                if (playersDiv) {
                    playersDiv.innerHTML = '';
                    
                    match.players.forEach(player => {
                        const playerElement = document.createElement('div');
                        playerElement.className = 'player-item';
                        playerElement.textContent = player.name;
                        playersDiv.appendChild(playerElement);
                    });
                }
                
                // Show voting section if in voting state, otherwise show game info
                if (match.gameState === 'voting_continue' || match.gameState === 'voting_imposter') {
                    hasVoted = false; // Reset voting flag
                    enableVotingButtons(); // Enable buttons
                    
                    // Hide game info and show voting section
                    document.getElementById('game-info').classList.add('hidden');
                    document.getElementById('voting-section').classList.remove('hidden');
                    
                    // Always hide word input during voting
                    document.getElementById('word-input-section').classList.add('hidden');
                    
                    if (match.gameState === 'voting_continue') {
                        document.getElementById('continue-voting-inline').classList.remove('hidden');
                        document.getElementById('imposter-voting-inline').classList.add('hidden');
                    } else {
                        document.getElementById('continue-voting-inline').classList.add('hidden');
                        document.getElementById('imposter-voting-inline').classList.remove('hidden');
                        updateVotingPlayersInline(match.players);
                    }
                    
                    // Update voting status when showing match
                    updateVotingStatus(match.players, match.votes || []);
                } else {
                    // Show game info, hide voting section for normal gameplay
                    document.getElementById('game-info').classList.remove('hidden');
                    document.getElementById('voting-section').classList.add('hidden');
                    
                    // Load and display all rounds data if available
                    console.log('updateMatchDisplay - allRounds:', match.allRounds);
                    if (match.allRounds && match.allRounds.length > 0) {
                        allRounds = match.allRounds;
                        console.log('updateMatchDisplay - allRounds loaded, calling displayAllRounds');
                        // Force display all rounds with a small delay to ensure DOM is ready
                        setTimeout(() => {
                            console.log('Delayed displayAllRounds call from updateMatchDisplay');
                            displayAllRounds();
                        }, 100);
                    }
                }
            }
        }
        
        function showError(message) {
            // Hide old message first
            const oldError = document.getElementById('error-message-fixed');
            const oldSuccess = document.getElementById('success-message-fixed');
            oldError.classList.add('hidden');
            oldSuccess.classList.add('hidden');
            
            // Show new error message
            const errorDiv = document.getElementById('error-message-fixed');
            errorDiv.textContent = message;
            errorDiv.classList.remove('hidden');
            setTimeout(() => errorDiv.classList.add('hidden'), 5000);
        }
        
        function showSuccess(message) {
            // Hide old message first
            const oldError = document.getElementById('error-message-fixed');
            const oldSuccess = document.getElementById('success-message-fixed');
            oldError.classList.add('hidden');
            oldSuccess.classList.add('hidden');
            
            // Show new success message
            const successDiv = document.getElementById('success-message-fixed');
            successDiv.textContent = message;
            successDiv.classList.remove('hidden');
            setTimeout(() => successDiv.classList.add('hidden'), 5000);
        }
        
        function hideError() {
            document.getElementById('error-message-fixed').classList.add('hidden');
            document.getElementById('success-message-fixed').classList.add('hidden');
        }
        
        // Private match checkbox
        document.getElementById('private-match').addEventListener('change', function() {
            const passwordField = document.getElementById('match-password');
            if (this.checked) {
                passwordField.classList.remove('hidden');
            } else {
                passwordField.classList.add('hidden');
                passwordField.value = '';
            }
        });
        
        // Game Functions
        let isCreatingMatch = false; // Prevent multiple simultaneous create attempts
        
        // Debug functions for console testing
        window.debugCreateMatch = function() {
            console.log('=== Debug Create Match ===');
            console.log('currentUser:', currentUser);
            console.log('isCreatingMatch:', isCreatingMatch);
            console.log('socket.connected:', socket.connected);
            console.log('=========================');
            if (isCreatingMatch) {
                console.log('Resetting isCreatingMatch flag...');
                isCreatingMatch = false;
            }
            createMatch();
        };
        
        window.resetFlags = function() {
            console.log('Resetting all flags...');
            isCreatingMatch = false;
            currentMatchId = null;
            isHost = false;
            console.log('Flags reset:', { isCreatingMatch, currentMatchId, isHost });
        };
        
        function createMatch() {
            console.log('createMatch() called. Current user:', currentUser, 'isCreatingMatch:', isCreatingMatch);
            
            if (!currentUser) {
                showError('Du musst eingeloggt sein');
                return;
            }
            
            if (isCreatingMatch) {
                console.log('Match creation already in progress, returning');
                return;
            }
            
            console.log('Starting match creation...');
            isCreatingMatch = true;
            
            const isPrivate = document.getElementById('private-match').checked;
            const password = document.getElementById('match-password').value;
            
            console.log('Sending create_match event:', { isPrivate, password: isPrivate ? password : null });
            
            socket.emit('create_match', {
                isPrivate: isPrivate,
                password: isPrivate ? password : null
            });
            
            console.log('create_match event sent to server');
            
            // Reset flag after a timeout
            setTimeout(() => {
                if (isCreatingMatch) {
                    console.log('Match creation timeout, resetting flag');
                    isCreatingMatch = false;
                }
            }, 2000);
        }
        
        function joinMatch() {
            if (!currentUser) {
                showError('Du musst eingeloggt sein');
                return;
            }
            
            const matchId = document.getElementById('match-id').value.trim().toUpperCase();
            const password = document.getElementById('join-password').value;
            
            if (!matchId) {
                showError('Bitte gib die Spiel-ID ein');
                return;
            }
            
            socket.emit('join_match', {
                matchId: matchId,
                password: password
            });
        }
        
        function startGame() {
            // Check if enough players
            if (!currentPlayers || currentPlayers.length < 4) {
                showError('Mindestens 4 Spieler werden ben√∂tigt um zu starten');
                return;
            }

            // Send start countdown event to all players
            socket.emit('start_countdown');
        }
        
        function showCountdown(word, isImposter) {
            const countdownOverlay = document.getElementById('countdown-overlay');
            const countdownTitle = document.getElementById('countdown-title');
            const countdownNumber = document.getElementById('countdown-number');
            const countdownCircle = document.getElementById('countdown-circle');
            const wordDisplay = document.getElementById('word-display');
            const wordTitle = document.getElementById('word-title');
            const wordText = document.getElementById('word-text');
            
            // Play countdown sound effect
            try {
                const audio = new Audio('/sounds/reveal.mp3');
                audio.volume = 0.7;
                audio.play().catch(e => console.log('Could not play countdown sound (this is normal if file not found):', e));
            } catch (e) {
                console.log('Countdown sound playback error (this is normal if file not found):', e);
            }
            
            // Hide lobby/waiting room when countdown starts
            hideAllScreens();
            
            // Show countdown overlay
            countdownOverlay.classList.add('show');
            
            // Phase 1: Countdown (5 seconds)
            let countdown = 5;
            countdownNumber.textContent = countdown;
            
            const countdownInterval = setInterval(() => {
                countdown--;
                if (countdown > 0) {
                    countdownNumber.textContent = countdown;
                } else {
                    clearInterval(countdownInterval);
                    
                    // Phase 2: Show word (3 seconds)
                    showWordPhase(word, isImposter, countdownTitle, countdownCircle, wordDisplay, wordTitle, wordText, countdownOverlay);
                }
            }, 1000);
        }
        
        function showWordPhase(word, isImposter, countdownTitle, countdownCircle, wordDisplay, wordTitle, wordText, countdownOverlay) {
            // Hide countdown elements
            countdownTitle.style.display = 'none';
            countdownCircle.style.display = 'none';
            
            // Show word display
            wordDisplay.style.display = 'block';
            
            if (isImposter) {
                wordTitle.textContent = 'Du bist der Imposter!';
                wordText.textContent = word || 'Finde das geheime Wort';
                wordText.classList.add('imposter');
            } else {
                wordTitle.textContent = 'Dein Wort:';
                wordText.textContent = word || 'Kein Wort';
                wordText.classList.remove('imposter');
            }
            
            // Hide after 3 seconds
            setTimeout(() => {
                countdownOverlay.classList.remove('show');
                
                // Reset for next time
                setTimeout(() => {
                    countdownTitle.style.display = 'block';
                    countdownTitle.textContent = 'Spiel startet gleich...';
                    countdownCircle.style.display = 'flex';
                    wordDisplay.style.display = 'none';
                    wordText.classList.remove('imposter');
                }, 300);
            }, 3000);
        }
        
        function showGameFinishedOverlay(data) {
            console.log('Showing game finished overlay with data:', data);
            
            // Play sound effect
            try {
                const audio = new Audio('/sounds/reveal.mp3');
                audio.volume = 0.7;
                audio.play().catch(e => console.log('Could not play sound:', e));
            } catch (e) {
                console.log('Sound playback error:', e);
            }
            
            const overlay = document.getElementById('game-finished-overlay');
            const icon = document.getElementById('game-result-icon');
            const title = document.getElementById('game-result-title');
            const content = document.getElementById('game-result-content');
            const wordElement = document.getElementById('result-word');
            const timerElement = document.getElementById('return-timer');
            const countdownBar = document.getElementById('return-countdown-bar');
            
            // Hide all other screens
            hideAllScreens();
            
            // Set content based on game result
            if (data.imposterWon) {
                icon.textContent = 'üé≠';
                title.textContent = 'Der Imposter hat gewonnen!';
                title.style.background = 'linear-gradient(45deg, #ff6b6b, #ee5a24)';
                title.style.webkitBackgroundClip = 'text';
                title.style.webkitTextFillColor = 'transparent';
                title.style.backgroundClip = 'text';
                
                content.innerHTML = `
                    <h3>üé≠ Sieg f√ºr den Imposter!</h3>
                    <p>Imposter: <strong>${data.imposter}</strong></p>
                    ${data.reason ? `<p>Grund: <strong>${data.reason}</strong></p>` : ''}
                `;
                
                // Adjust overlay background for imposter win
                document.querySelector('.game-finished-window').style.background = 
                    'linear-gradient(135deg, #ff6b6b 0%, #ee5a24 50%, #ff9ff3 100%)';
            } else {
                icon.textContent = 'üéâ';
                title.textContent = 'Die Spieler haben gewonnen!';
                title.style.background = 'linear-gradient(45deg, #4ecdc4, #44a08d)';
                title.style.webkitBackgroundClip = 'text';
                title.style.webkitTextFillColor = 'transparent';
                title.style.backgroundClip = 'text';
                
                content.innerHTML = `
                    <h3>üéâ Sieg f√ºr die Spieler!</h3>
                    <p>Der Imposter <strong>${data.imposter}</strong> wurde entlarvt!</p>
                    ${data.reason ? `<p>Grund: <strong>${data.reason}</strong></p>` : ''}
                `;
                
                // Adjust overlay background for players win
                document.querySelector('.game-finished-window').style.background = 
                    'linear-gradient(135deg, #4ecdc4 0%, #44a08d 50%, #96ceb4 100%)';
            }
            
            // Set the word
            wordElement.textContent = data.word;
            
            // Show overlay with animation
            overlay.classList.add('show');
            
            // Start 15-second countdown
            let timeLeft = 15;
            timerElement.textContent = timeLeft;
            countdownBar.style.width = '100%';
            
            const countdownInterval = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                // Update progress bar
                const percentage = (timeLeft / 15) * 100;
                countdownBar.style.width = percentage + '%';
                
                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    returnToLobbyManually();
                }
            }, 1000);
            
            // Store interval ID to clear it if user returns manually
            window.gameFinishedCountdown = countdownInterval;
        }
        
        function showVotingResultOverlay(data) {
            console.log('Showing voting result overlay with data:', data);
            
            // Play sound effect
            try {
                const audio = new Audio('/sounds/reveal.mp3');
                audio.volume = 0.5;
                audio.play().catch(e => console.log('Could not play voting sound:', e));
            } catch (e) {
                console.log('Voting sound playback error:', e);
            }
            
            const overlay = document.getElementById('voting-result-overlay');
            const icon = document.getElementById('voting-result-icon');
            const title = document.getElementById('voting-result-title');
            const content = document.getElementById('voting-result-content');
            const timerElement = document.getElementById('voting-timer');
            const countdownBar = document.getElementById('voting-countdown-bar');
            const window = document.querySelector('.voting-result-window');
            
            // CACHE-BUSTER v1.3: Don't hide all screens for imposter voting - keep voting interface visible
            if (data.type === 'imposter_voting') {
                console.log('üîç IMPOSTER VOTING OVERLAY - NOT hiding all screens to keep voting interface visible');
                // Don't hide all screens for imposter voting, just hide specific overlays
                document.getElementById('game-finished-overlay').classList.remove('show');
                hideVotingResultOverlay(); // Hide any existing voting result overlay
            } else {
                console.log('üì§ OTHER OVERLAY TYPE - hiding all screens normally');
                // Hide all other screens for non-imposter voting overlays
                hideAllScreens();
            }
            
            // Reset window classes
            window.className = 'voting-result-window';
            
            // Set content based on voting result type
            if (data.type === 'continue') {
                // Game continues to next round
                icon.textContent = '‚ñ∂Ô∏è';
                title.textContent = 'Spiel geht weiter!';
                window.classList.add('continue-game');
                
                content.innerHTML = `
                    <h3>üéØ Weiter zur n√§chsten Runde!</h3>
                    <p>Die Spieler haben sich entschieden <strong>weiterzuspielen</strong>.</p>
                    <p>Das Spiel geht in Runde <strong>${data.nextRound || (data.currentRound + 1)}</strong>.</p>
                `;
                
            } else if (data.type === 'player_eliminated') {
                // Player was voted out but was innocent
                icon.textContent = 'üëã';
                title.textContent = 'Spieler eliminiert!';
                window.classList.add('player-eliminated');
                
                const eliminatedPlayerName = data.eliminatedPlayer || 'Unbekannt';
                content.innerHTML = `
                    <h3>‚öñÔ∏è Spieler wurde rausgew√§hlt!</h3>
                    <p><strong>${eliminatedPlayerName}</strong> wurde eliminiert.</p>
                    <p>‚ùå Es war nicht der Imposter!</p>
                    <p>${eliminatedPlayerName} ist jetzt <strong>Zuschauer</strong>.</p>
                `;
                
            } else if (data.type === 'tied_vote') {
                // Tied vote, game continues
                icon.textContent = '‚öñÔ∏è';
                title.textContent = 'Unentschieden!';
                window.classList.add('tied-vote');
                
                content.innerHTML = `
                    <h3>‚öñÔ∏è Abstimmung unentschieden!</h3>
                    <p>Es gab keinen klaren Gewinner bei der Abstimmung.</p>
                    <p>Das Spiel <strong>geht weiter</strong>!</p>
                `;
                
            } else if (data.type === 'imposter_voting') {
                // Switching to imposter voting
                icon.textContent = 'üîç';
                title.textContent = 'Imposter-Suche!';
                window.classList.add('continue-game');
                
                content.innerHTML = `
                    <h3>üïµÔ∏è Zeit den Imposter zu finden!</h3>
                    <p>Die Spieler haben sich entschieden, den <strong>Imposter zu erraten</strong>.</p>
                    <p>W√§hlt weise - ihr habt nur eine Chance!</p>
                `;
            }
            
            // Show overlay with animation
            overlay.classList.add('show');
            
            // Start 5-second countdown
            let timeLeft = 5;
            timerElement.textContent = timeLeft;
            countdownBar.style.width = '100%';
            
            const countdownInterval = setInterval(() => {
                timeLeft--;
                timerElement.textContent = timeLeft;
                
                // Update progress bar
                const percentage = (timeLeft / 5) * 100;
                countdownBar.style.width = percentage + '%';
                
                if (timeLeft <= 0) {
                    clearInterval(countdownInterval);
                    hideVotingResultOverlay();
                }
            }, 1000);
            
            // Store interval ID to clear it if needed
            window.votingResultCountdown = countdownInterval;
        }
        
        function hideVotingResultOverlay() {
            const overlay = document.getElementById('voting-result-overlay');
            if (overlay) {
                overlay.classList.remove('show');
            }
            
            // Clear countdown if it's running
            if (window.votingResultCountdown) {
                clearInterval(window.votingResultCountdown);
                window.votingResultCountdown = null;
            }
        }
        
        function submitWord() {
            const word = document.getElementById('word-input').value.trim();
            if (!word) {
                showError('Bitte gib ein Wort ein');
                return;
            }
            
            // Store the word input in case we need to show the section again on error
            const wordInput = document.getElementById('word-input');
            const wordInputSection = document.getElementById('word-input-section');
            
            socket.emit('submit_word', { word: word });
            wordInput.value = '';
            wordInputSection.classList.add('hidden');
        }
        
        function vote(voteType, targetPlayerId = null) {
            console.log('Vote function called:', voteType, 'hasVoted before:', hasVoted);
            
            // Check if user is a spectator (eliminated player)
            if (isSpectator) {
                showError('Zuschauer k√∂nnen nicht abstimmen!');
                return;
            }
            
            // Check if user has already voted
            if (hasVoted) {
                showError('Du hast bereits abgestimmt!');
                return;
            }
            
            // Prevent self-voting when voting for imposter
            if (voteType === 'imposter' && targetPlayerId) {
                const currentPlayerName = myPlayerName || (currentUser ? currentUser.username : null) || getPlayerName();
                const targetPlayer = currentPlayers.find(p => p.id === targetPlayerId);
                if (targetPlayer && targetPlayer.name === currentPlayerName) {
                    showError('Du kannst nicht f√ºr dich selbst stimmen!');
                    return;
                }
            }
            
            // Immediately mark user as having voted to prevent double-voting
            hasVoted = true;
            console.log('Set hasVoted to true');
            
            // Immediately hide voting interfaces to provide instant feedback
            document.getElementById('continue-voting').classList.add('hidden');
            document.getElementById('imposter-voting').classList.add('hidden');
            document.getElementById('continue-voting-inline').classList.add('hidden');
            document.getElementById('imposter-voting-inline').classList.add('hidden');
            
            // Immediately hide ALL player voting buttons when any vote is made
            const playerVoteButtons = document.querySelectorAll('.vote-player-btn');
            console.log('Found', playerVoteButtons.length, 'player vote buttons to hide');
            playerVoteButtons.forEach(button => {
                button.style.display = 'none';
            });
            
            // Also disable all other voting buttons
            disableVotingButtons();
            
            // Show immediate feedback
            const votingStatus = document.getElementById('voting-status-inline') || document.getElementById('voting-status');
            if (votingStatus) {
                votingStatus.innerHTML = '<p style="color: #90EE90; text-align: center; font-weight: bold;">‚úÖ Stimme wird √ºbertragen...</p>';
            }
            
            // Send vote to server
            socket.emit('submit_vote', {
                voteType: voteType,
                targetPlayerId: targetPlayerId
            });
        }
        
        function disableVotingButtons() {
            // Disable continue voting buttons
            const continueButtons = document.querySelectorAll('#continue-voting button');
            continueButtons.forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
            });
            
            // Disable imposter voting buttons
            const imposterButtons = document.querySelectorAll('#imposter-voting button');
            imposterButtons.forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
            });
            
            // Disable inline voting buttons
            const inlineContinueButtons = document.querySelectorAll('#continue-voting-inline button');
            inlineContinueButtons.forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
            });
            
            const inlineImposterButtons = document.querySelectorAll('#imposter-voting-inline button');
            inlineImposterButtons.forEach(button => {
                button.disabled = true;
                button.style.opacity = '0.5';
                button.style.cursor = 'not-allowed';
            });
            
            // Hide player voting buttons completely (redundant but safer)
            const playerVoteButtons = document.querySelectorAll('.vote-player-btn');
            playerVoteButtons.forEach(button => {
                button.style.display = 'none';
                button.disabled = true;
            });
            
            // Also try hiding by container ID as backup
            const votePlayersContainer = document.getElementById('vote-players');
            const votePlayersInlineContainer = document.getElementById('vote-players-inline');
            if (votePlayersContainer) {
                const buttons = votePlayersContainer.querySelectorAll('button');
                buttons.forEach(btn => btn.style.display = 'none');
            }
            if (votePlayersInlineContainer) {
                const buttons = votePlayersInlineContainer.querySelectorAll('button');
                buttons.forEach(btn => btn.style.display = 'none');
            }
        }
        
        function enableVotingButtons() {
            // Enable continue voting buttons
            const continueButtons = document.querySelectorAll('#continue-voting button');
            continueButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            });
            
            // Enable imposter voting buttons
            const imposterButtons = document.querySelectorAll('#imposter-voting button');
            imposterButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            });
            
            // Enable inline voting buttons
            const inlineContinueButtons = document.querySelectorAll('#continue-voting-inline button');
            inlineContinueButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            });
            
            const inlineImposterButtons = document.querySelectorAll('#imposter-voting-inline button');
            inlineImposterButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
            });
            
            // Show player voting buttons again
            const playerVoteButtons = document.querySelectorAll('.vote-player-btn');
            playerVoteButtons.forEach(button => {
                button.disabled = false;
                button.style.opacity = '1';
                button.style.cursor = 'pointer';
                button.style.display = ''; // Reset display to show buttons again
            });
            
            // Also restore visibility by container ID as backup
            const votePlayersContainer = document.getElementById('vote-players');
            const votePlayersInlineContainer = document.getElementById('vote-players-inline');
            if (votePlayersContainer) {
                const buttons = votePlayersContainer.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.style.display = '';
                    btn.disabled = false;
                });
            }
            if (votePlayersInlineContainer) {
                const buttons = votePlayersInlineContainer.querySelectorAll('button');
                buttons.forEach(btn => {
                    btn.style.display = '';
                    btn.disabled = false;
                });
            }
        }
        
        function updateVotingStatus(players, votes) {
            const votingStatus = document.getElementById('voting-status-inline') || document.getElementById('voting-status');
            if (!votingStatus) return;
            
            if (!players || !Array.isArray(players)) return;
            
            const votedPlayerIds = votes ? votes.map(v => v.playerId) : [];
            const voted = [];
            const notVoted = [];
            
            players.forEach(player => {
                if (votedPlayerIds.includes(player.id)) {
                    voted.push(player.name);
                } else {
                    notVoted.push(player.name);
                }
            });
            
            let statusHTML = '<div style="text-align: left;">';
            
            if (voted.length > 0) {
                statusHTML += '<p style="color: #90EE90; margin: 5px 0;"><strong>‚úÖ Bereits gevotet:</strong></p>';
                statusHTML += '<p style="color: #90EE90; margin: 0 0 10px 20px;">' + voted.join(', ') + '</p>';
            }
            
            if (notVoted.length > 0) {
                statusHTML += '<p style="color: #fff; margin: 5px 0;"><strong>‚è≥ Warten auf:</strong></p>';
                statusHTML += '<p style="color: #fff; margin: 0 0 10px 20px;">' + notVoted.join(', ') + '</p>';
            }
            
            if (notVoted.length === 0) {
                statusHTML += '<p style="color: #90EE90; margin: 10px 0;"><strong>üéâ Alle haben gevotet!</strong></p>';
            }
            
            statusHTML += '</div>';
            votingStatus.innerHTML = statusHTML;
        }
        
        function leaveMatch() {
            // Immediately reset local state for better UX
            console.log('leaveMatch() called - immediately resetting client state');
            
            // Reset all local state immediately
            currentMatchId = null;
            isHost = false;
            isSpectator = false; // Reset spectator status
            myPlayerName = null;
            currentPlayers = [];
            window.createdThisMatch = false;
            isCreatingMatch = false;
            
            // Clear saved spectator status
            localStorage.removeItem('imposterSpectator');
            console.log('üé≠ CLEAR: Spectator status cleared from localStorage');
            
            // Clear URL and go to main menu immediately
            updateURL();
            hideAllScreens();
            hideGamePlayersList();
            showMainMenu();
            
            // Show immediate feedback
            showSuccess('Du hast die Lobby verlassen');
            
            // Send leave event to server (but don't wait for response)
            socket.emit('leave_match');
        }
        
        function returnToMainMenu() {
            // Confirm the user wants to leave the game
            if (confirm('M√∂chtest du wirklich das Spiel verlassen und zum Hauptmen√º zur√ºckkehren?')) {
                leaveMatch();
            }
        }
        
        function returnToLobbyManually() {
            // Clear the game finished countdown if it's running
            if (window.gameFinishedCountdown) {
                clearInterval(window.gameFinishedCountdown);
                window.gameFinishedCountdown = null;
            }
            
            // Hide the game finished overlay if it's showing
            const overlay = document.getElementById('game-finished-overlay');
            if (overlay) {
                overlay.classList.remove('show');
            }
            
            if (currentMatchId) {
                hideAllScreens();
                document.getElementById('waiting-room').classList.remove('hidden');
                document.getElementById('user-profile').classList.remove('hidden');
                hideGamePlayersList();
                
                // Update players list if we have current players
                if (currentPlayers && currentPlayers.length > 0) {
                    updatePlayersList(currentPlayers);
                }
            } else {
                showMainMenu();
            }
        }
        
        // Helper function to manage start game button visibility
        function updateStartGameButton() {
            const startBtn = document.getElementById('start-game-btn');
            console.log('updateStartGameButton called - isHost:', isHost, 'currentPlayers length:', currentPlayers ? currentPlayers.length : 'undefined');
            
            // Show button if user is host (regardless of player count for now)
            // Button will be enabled/disabled based on player count
            if (isHost) {
                console.log('Showing start button (user is host)');
                startBtn.classList.remove('hidden');
                
                // Enable/disable based on player count
                if (currentPlayers && currentPlayers.length >= 4) {
                    startBtn.disabled = false;
                    startBtn.textContent = 'Spiel starten';
                } else {
                    startBtn.disabled = true;
                    startBtn.textContent = 'Warte auf Spieler (min. 4)';
                }
            } else {
                console.log('Hiding start button (user is not host)');
                startBtn.classList.add('hidden');
                startBtn.disabled = false;
                startBtn.textContent = 'Spiel starten';
            }
        }
        
        // Socket Events
        socket.on('match_created', (data) => {
            console.log('match_created event received:', data);
            console.log('Current state - isCreatingMatch:', isCreatingMatch, 'currentMatchId:', currentMatchId);
            isCreatingMatch = false; // Reset the creation flag
            currentMatchId = data.matchId;
            isHost = true;
            currentPlayers = [{ name: myPlayerName || (currentUser ? currentUser.username : null) || getPlayerName(), isHost: true }]; // Add ourselves to the players list
            updateURL(data.matchId); // Update URL when match is created
            document.getElementById('current-match-id').textContent = data.matchId;
            hideAllScreens();
            document.getElementById('waiting-room').classList.remove('hidden');
            console.log('Set isHost to true, calling updateStartGameButton');
            
            // Set a flag to remember we created this match
            window.createdThisMatch = true;
            
            updateStartGameButton(); // Update button visibility
            updatePlayersList(currentPlayers); // Update the players list display
            
            console.log('match_created processing complete, should now be in waiting room');
        });
        
        socket.on('match_joined', (data) => {
            currentMatchId = data.matchId;
            updateURL(data.matchId); // Update URL when match is joined
            document.getElementById('current-match-id').textContent = data.matchId;
            hideAllScreens();
            document.getElementById('waiting-room').classList.remove('hidden');
            
            // Initially hide start button - will be shown by match_updated if user is host
            document.getElementById('start-game-btn').classList.add('hidden');
        });
        
        socket.on('match_updated', (data) => {
            // Only process if we're currently in a match
            if (!currentMatchId) {
                return;
            }
            
            currentPlayers = data.players || []; // Store players globally
            updatePlayersList(data.players);
            
            // Check if current user became the host
            const playerName = myPlayerName || (currentUser ? currentUser.username : null) || getPlayerName();
            if (playerName) {
                const currentPlayer = data.players.find(p => p.name === playerName);
                if (currentPlayer) {
                    const wasHost = isHost;
                    
                    // If we created this match, we should always be host (unless we left and rejoined)
                    if (window.createdThisMatch && currentPlayer.isHost) {
                        isHost = true;
                    } else {
                        isHost = currentPlayer.isHost;
                    }
                    
                    // Show notification if user became host
                    if (!wasHost && isHost) {
                        showSuccess('Du bist jetzt der Host!');
                    }
                } else {
                }
            } else {
            }
            
            // Also update the game players list if we're in a game
            if (data.gameState === 'playing' || data.gameState === 'voting_continue' || data.gameState === 'voting_imposter') {
                updateGamePlayersList(data.players, data.currentPlayer || currentPlayerName);
            }
            
            // Show/hide start button based on host status and player count
            updateStartGameButton();
        });
        
        // Helper function to reset all game-specific data for a fresh start
        function resetGameData() {
            console.log('RESET: Resetting all game data for fresh start');
            
            // Reset all voting and game state
            hasVoted = false;
            currentVotingType = null;
            
            // Only reset spectator status if not currently a spectator (to preserve eliminated player status)
            const wasSpectator = isSpectator;
            if (!wasSpectator) {
                isSpectator = false; // Only reset for non-spectators (new games)
                localStorage.removeItem('imposterSpectator'); // Clear saved status for new games
            } else {
                console.log('üé≠ PRESERVE: Keeping spectator status during reset (eliminated player)');
            }
            
            // Reset player data
            playerWord = null;
            isImposter = false;
            currentPlayerName = null;
            
            // Reset rounds data
            allRounds = [];
            
            // Hide all voting interfaces
            document.getElementById('voting-section').classList.add('hidden');
            document.getElementById('continue-voting').classList.add('hidden');
            document.getElementById('imposter-voting').classList.add('hidden');
            document.getElementById('continue-voting-inline').classList.add('hidden');
            document.getElementById('imposter-voting-inline').classList.add('hidden');
            document.getElementById('voting-screen').classList.add('hidden');
            
            // Hide word input initially
            document.getElementById('word-input-section').classList.add('hidden');
            
            // Clear words list
            const wordsList = document.getElementById('words-list');
            if (wordsList) {
                wordsList.innerHTML = '';
            }
            
            // Enable voting buttons for new game
            enableVotingButtons();
            
            console.log('RESET: Game data reset complete - hasVoted:', hasVoted, 'isSpectator:', isSpectator, 'hasVoted:', hasVoted);
        }

        socket.on('countdown_started', (data) => {
            console.log('Countdown started for all players with data:', data);
            
            // IMPORTANT: Reset ALL game data when countdown starts for a truly fresh game
            resetGameData();
            
            showCountdown(data.word, data.isImposter);
        });

        socket.on('game_started', (data) => {
            console.log('game_started event received:', data);
            
            // IMPORTANT: Always reset game data first, then apply server data
            resetGameData();
            
            playerWord = data.word;
            isImposter = data.isImposter;
            
            // IMPORTANT: Set spectator status from server data (overwrites reset)
            if (data.spectatorMode !== undefined) {
                isSpectator = data.spectatorMode;
                console.log('OVERRIDE: Setting isSpectator from server:', isSpectator);
                
                // Persist spectator status in localStorage for page reloads
                if (isSpectator) {
                    localStorage.setItem('imposterSpectator', 'true');
                } else {
                    localStorage.removeItem('imposterSpectator');
                }
            }
            
            currentPlayerName = data.currentPlayer;
            
            // Show game info section (normal gameplay view)
            document.getElementById('game-info').classList.remove('hidden');
            
            // Update word display based on spectator status
            if (isSpectator) {
                console.log('üé≠ SPECTATOR MODE: Setting up spectator UI');
                document.getElementById('player-word').textContent = 'Zuschauer-Modus';
                document.getElementById('player-word').className = 'spectator-word';
                
                // Immediately hide ALL voting and input interfaces for spectators
                document.getElementById('voting-section').classList.add('hidden');
                document.getElementById('continue-voting').classList.add('hidden');
                document.getElementById('imposter-voting').classList.add('hidden');
                document.getElementById('continue-voting-inline').classList.add('hidden');
                document.getElementById('imposter-voting-inline').classList.add('hidden');
                document.getElementById('word-input-section').classList.add('hidden');
                
                // Ensure game info is visible for spectators
                document.getElementById('game-info').classList.remove('hidden');
                
                // Show spectator-specific content in words list
                const wordsList = document.getElementById('words-list');
                if (wordsList) {
                    wordsList.innerHTML = '<div class="spectator-info" style="text-align: center; padding: 20px; color: #999; font-style: italic;">Du bist Zuschauer und kannst das Spiel verfolgen.</div>';
                }
                
                console.log('üé≠ SPECTATOR MODE: UI setup complete');
            } else {
                document.getElementById('player-word').textContent = data.word;
                document.getElementById('player-word').className = data.isImposter ? 'imposter-word' : '';
            }
            
            document.getElementById('current-player').textContent = data.currentPlayer;
            document.getElementById('current-round').textContent = data.round;
            
            hideAllScreens();
            document.getElementById('game-screen').classList.remove('hidden');
            showGamePlayersList(); // Show players list when game starts
            
            // Debug: Check if element exists
            setTimeout(() => {
                checkPlayersListElement();
            }, 100);
            
            // Update players list in game screen
            let playersToShow = data.players;
            if (!playersToShow || !Array.isArray(playersToShow)) {
                console.log('No players in game_started, using stored players:', currentPlayers);
                playersToShow = currentPlayers;
            }
            
            if (playersToShow && Array.isArray(playersToShow) && playersToShow.length > 0) {
                console.log('Real players data found:', playersToShow);
                updateGamePlayersList(playersToShow, data.currentPlayer);
            } else {
                // Fallback: show test data
                console.warn('No valid players data available, showing test data');
                setTimeout(() => {
                    testPlayersDisplay();
                }, 200);
            }
            
            // Show input if it's player's turn (but not for spectators)
            const playerName = myPlayerName || (currentUser ? currentUser.username : null) || getPlayerName();
            console.log('Checking if should show word input - currentPlayer:', data.currentPlayer, 'playerName:', playerName, 'isSpectator:', isSpectator);
            
            if (data.currentPlayer === playerName && !isSpectator) {
                console.log('Showing word input for current player');
                document.getElementById('word-input-section').classList.remove('hidden');
            } else {
                console.log('Hiding word input - not current player or spectator');
                document.getElementById('word-input-section').classList.add('hidden');
            }
            
            // Clear any existing word input value
            const wordInput = document.getElementById('word-input');
            if (wordInput) {
                wordInput.value = '';
            }
        });
        
        socket.on('word_submitted', (data) => {
            console.log('word_submitted event received:', data);
            
            // If this is round 1 and no words yet, it means this is a fresh start - reset everything
            if (data.round === 1 && (!data.words || data.words.length <= 1)) {
                console.log('Fresh game start detected - resetting all UI');
                // Reset voting interfaces
                document.getElementById('voting-section').classList.add('hidden');
                document.getElementById('continue-voting').classList.add('hidden');
                document.getElementById('imposter-voting').classList.add('hidden');
                document.getElementById('continue-voting-inline').classList.add('hidden');
                document.getElementById('imposter-voting-inline').classList.add('hidden');
                document.getElementById('voting-screen').classList.add('hidden');
                
                // Show game info section
                document.getElementById('game-info').classList.remove('hidden');
                
                // Reset voting state
                hasVoted = false;
                currentVotingType = null;
            }
            
            // Spectators should not participate in voting
            if (isSpectator) {
                console.log('Spectator detected - only updating words list, no voting UI');
                // Update with all rounds data from server
                if (data.allRounds) {
                    allRounds = data.allRounds;
                }
                // Only update words list for spectators
                updateWordsList(data.words, data.round);
                // Ensure ALL voting interfaces are hidden for spectators
                document.getElementById('voting-section').classList.add('hidden');
                document.getElementById('continue-voting').classList.add('hidden');
                document.getElementById('imposter-voting').classList.add('hidden');
                document.getElementById('continue-voting-inline').classList.add('hidden');
                document.getElementById('imposter-voting-inline').classList.add('hidden');
                document.getElementById('word-input-section').classList.add('hidden');
                return;
            }
            
            // Update with all rounds data from server
            if (data.allRounds) {
                allRounds = data.allRounds;
            }
            
            // Always update the words list first, even if voting is starting
            updateWordsList(data.words, data.round);
            
            // Check if voting has started and show voting section
            if (data.gameState === 'voting_continue' || data.gameState === 'voting_imposter') {
                // Check if this is a new voting type (different from before)
                if (currentVotingType !== data.gameState) {
                    console.log('New voting type detected:', data.gameState, 'previous:', currentVotingType);
                    currentVotingType = data.gameState;
                    hasVoted = false; // Reset for new voting type
                }
                
                if (!hasVoted) {
                    // Hide game info and show voting section
                    document.getElementById('game-info').classList.add('hidden');
                    document.getElementById('voting-section').classList.remove('hidden');
                }
                
                // Always hide word input during voting
                document.getElementById('word-input-section').classList.add('hidden');
                
                if (data.gameState === 'voting_continue') {
                    if (!hasVoted && !isSpectator) {
                        document.getElementById('continue-voting-inline').classList.remove('hidden');
                    }
                    document.getElementById('imposter-voting-inline').classList.add('hidden');
                } else {
                    document.getElementById('continue-voting-inline').classList.add('hidden');
                    if (!hasVoted && !isSpectator) {
                        document.getElementById('imposter-voting-inline').classList.remove('hidden');
                        updateVotingPlayersInline(data.players);
                    }
                }
                
                // Initialize voting status (no votes yet at start)
                updateVotingStatus(data.players, []);
                
                return; // Don't continue with normal word display logic
            }
            
            currentPlayerName = data.currentPlayer;
            
            // Update players list with current player highlight
            let playersToShow = data.players;
            if (!playersToShow || !Array.isArray(playersToShow)) {
                console.log('No players in word_submitted, using stored players:', currentPlayers);
                playersToShow = currentPlayers;
            }
            
            if (playersToShow && Array.isArray(playersToShow) && playersToShow.length > 0) {
                console.log('Updating players list with real data:', playersToShow);
                updateGamePlayersList(playersToShow, data.currentPlayer);
            } else {
                console.warn('No valid players data available for word_submitted');
            }
            
            if (data.currentPlayer) {
                document.getElementById('current-player').textContent = data.currentPlayer;
                document.getElementById('current-round').textContent = data.round;
                
                const playerName = myPlayerName || (currentUser ? currentUser.username : null) || getPlayerName();
                console.log('word_submitted - Checking if should show word input - currentPlayer:', data.currentPlayer, 'playerName:', playerName, 'isSpectator:', isSpectator);
                
                if (data.currentPlayer === playerName && !isSpectator) {
                    console.log('word_submitted - Showing word input for current player');
                    document.getElementById('word-input-section').classList.remove('hidden');
                } else {
                    console.log('word_submitted - Hiding word input - not current player or spectator');
                    document.getElementById('word-input-section').classList.add('hidden');
                }
            }
            
            if (data.gameState === 'voting_continue') {
                // Show voting screen but keep game screen visible
                document.getElementById('voting-screen').classList.remove('hidden');
                document.getElementById('continue-voting').classList.remove('hidden');
                // Hide word input section during voting
                document.getElementById('word-input-section').classList.add('hidden');
            }
        });
        
        socket.on('vote_updated', (data) => {
            console.log('=== vote_updated received ===');
            console.log('data.gameState:', data.gameState);
            console.log('hasVoted before processing:', hasVoted);
            console.log('isSpectator:', isSpectator);
            
            // Process immediately - backend handles timing
            processVoteUpdate(data);
        });
        
        function processVoteUpdate(data) {
            // Spectators should not see voting interfaces
            if (isSpectator) {
                console.log('Spectator detected - hiding all voting interfaces');
                document.getElementById('voting-section').classList.add('hidden');
                document.getElementById('continue-voting').classList.add('hidden');
                document.getElementById('imposter-voting').classList.add('hidden');
                document.getElementById('continue-voting-inline').classList.add('hidden');
                document.getElementById('imposter-voting-inline').classList.add('hidden');
                document.getElementById('word-input-section').classList.add('hidden');
                return;
            }
            
            // Update with all rounds data from server
            if (data.allRounds) {
                allRounds = data.allRounds;
            }
            
            if (data.gameState === 'voting_imposter') {
                // Check if this is a new voting type
                if (currentVotingType !== data.gameState) {
                    console.log('New imposter voting detected, resetting hasVoted');
                    currentVotingType = data.gameState;
                    hasVoted = false; // Reset for new voting phase
                }
                
                console.log('Processing imposter voting - hasVoted:', hasVoted, 'isSpectator:', isSpectator);
                
                // Hide the old continue voting interface when switching to imposter voting
                document.getElementById('continue-voting-inline').classList.add('hidden');
                
                if (!hasVoted) {
                    enableVotingButtons(); // Enable buttons for new voting round
                    
                    // Hide game info and show voting section (only for active players)
                    if (!isSpectator) {
                        console.log('Showing voting section for imposter voting');
                        document.getElementById('game-info').classList.add('hidden');
                        document.getElementById('voting-section').classList.remove('hidden');
                    }
                }
                
                // Always hide word input during voting
                document.getElementById('word-input-section').classList.add('hidden');
                
                if (!isSpectator) {
                    console.log('Showing imposter voting inline interface');
                    document.getElementById('imposter-voting-inline').classList.remove('hidden');
                    updateVotingPlayersInline(data.players);
                } else {
                    console.log('User is spectator - hiding imposter voting interface');
                }
                
                // Update voting status
                updateVotingStatus(data.players, data.votes);
                
            } else if (data.gameState === 'voting_continue') {
                // Check if this is a new voting type
                if (currentVotingType !== data.gameState) {
                    console.log('New continue voting detected, resetting hasVoted');
                    currentVotingType = data.gameState;
                    hasVoted = false;
                }
                
                if (!hasVoted) {
                    enableVotingButtons(); // Enable buttons for new voting round
                }
                
                // Hide game info and show voting section (only for active players)
                if (!isSpectator) {
                    document.getElementById('game-info').classList.add('hidden');
                    document.getElementById('voting-section').classList.remove('hidden');
                }
                
                // Always hide word input during voting
                document.getElementById('word-input-section').classList.add('hidden');
                
                if (!hasVoted && !isSpectator) {
                    document.getElementById('continue-voting-inline').classList.remove('hidden');
                }
                document.getElementById('imposter-voting-inline').classList.add('hidden');
                
                // Update voting status
                updateVotingStatus(data.players, data.votes);
            } else if (data.gameState === 'playing') {
                // Reset voting flag when new game round starts
                hasVoted = false;
                currentVotingType = null; // Reset voting type as well
                // Hide voting section and show game info for new round (unless spectator)
                if (!isSpectator) {
                    document.getElementById('voting-section').classList.add('hidden');
                    document.getElementById('game-info').classList.remove('hidden');
                }
                updateWordsList(data.words, data.round);
                document.getElementById('current-player').textContent = data.currentPlayer;
                document.getElementById('current-round').textContent = data.round;
                
                const playerName = myPlayerName || (currentUser ? currentUser.username : null) || getPlayerName();
                console.log('game_updated playing - Checking if should show word input - currentPlayer:', data.currentPlayer, 'playerName:', playerName, 'isSpectator:', isSpectator);
                
                if (data.currentPlayer === playerName && !isSpectator) {
                    console.log('game_updated playing - Showing word input for current player');
                    document.getElementById('word-input-section').classList.remove('hidden');
                } else {
                    console.log('game_updated playing - Hiding word input - not current player or spectator');
                    document.getElementById('word-input-section').classList.add('hidden');
                }
            }
        }
        
        socket.on('game_finished', (data) => {
            showGameFinishedOverlay(data);
        });
        
        socket.on('return_to_lobby', (data) => {
            console.log('Returning to lobby:', data);
            
            // IMPORTANT: Reset ALL game data when returning to lobby
            resetGameData();
            
            // Update current players list
            currentPlayers = data.players || [];
            
            // Check if current user is host
            const currentPlayer = data.players.find(p => p.name === myPlayerName || p.name === getPlayerName());
            if (currentPlayer) {
                isHost = currentPlayer.isHost;
            }
            
            // Reset additional lobby-specific data
            playerWord = null;
            isImposter = false;
            currentPlayerName = null;
            
            // Hide game screens and show waiting room
            hideAllScreens();
            hideGamePlayersList();
            document.getElementById('waiting-room').classList.remove('hidden');
            document.getElementById('user-profile').classList.remove('hidden');
            
            // Update players list in waiting room
            updatePlayersList(data.players);
            
            // Show start button if user is host
            updateStartGameButton();
            
            showSuccess('Spiel beendet! Ihr seid zur√ºck in der Lobby.');
        });
        
        socket.on('match_left', () => {
            console.log('Match left confirmation received from server');
            // Client state is already reset, this is just confirmation
        });
        
        socket.on('error', (data) => {
            showError(data.message);
            isCreatingMatch = false; // Reset creation flag on error
            
            // If it's a word submission error, show the input section again (but not for spectators)
            if (data.message.includes('gesuchte Wort') || data.message.includes('target word')) {
                const currentPlayerName = getPlayerName();
                if (document.getElementById('current-player').textContent === currentPlayerName && !isSpectator) {
                    document.getElementById('word-input-section').classList.remove('hidden');
                }
            }
            
            // If joining via URL failed, clear the URL
            const urlMatchId = getMatchIdFromURL();
            if (urlMatchId && data.message.includes('Match') && (data.message.includes('gefunden') || data.message.includes('found'))) {
                updateURL(); // Clear URL if match not found
            }
        });
        
        // Handle when this player gets eliminated
        socket.on('player_eliminated', (data) => {
            console.log('This player was eliminated:', data);
            isSpectator = true; // Mark this player as spectator
            hasVoted = false; // Reset voting status since they're now a spectator
            currentVotingType = null; // Reset voting type
            
            // Update word display to spectator mode
            document.getElementById('player-word').textContent = 'Zuschauer-Modus';
            document.getElementById('player-word').className = 'spectator-word';
            
            // Hide all voting interfaces immediately
            document.getElementById('voting-section').classList.add('hidden');
            document.getElementById('continue-voting').classList.add('hidden');
            document.getElementById('imposter-voting').classList.add('hidden');
            document.getElementById('continue-voting-inline').classList.add('hidden');
            document.getElementById('imposter-voting-inline').classList.add('hidden');
            document.getElementById('word-input-section').classList.add('hidden');
            
            // Disable all voting buttons to be extra safe
            disableVotingButtons();
            
            // Show spectator message
            showError('Du wurdest eliminiert und bist jetzt Zuschauer! Du kannst das Spiel weiter beobachten.');
            
            // Update game info to show spectator status
            const gameInfo = document.getElementById('game-info');
            if (gameInfo) {
                gameInfo.innerHTML = `
                    <p style="color: #ff6b6b; font-weight: bold;">üîç ZUSCHAUER-MODUS</p>
                    <p>Du beobachtest das Spiel als Zuschauer</p>
                    <p>Runde: <span id="current-round">${data.currentRound || 'N/A'}</span></p>
                `;
                gameInfo.classList.remove('hidden');
            }
        });
        
        // Handle player elimination update for all players
        socket.on('player_eliminated_update', (data) => {
            console.log('Player elimination update received:', data);
            
            // Update current players list to reflect eliminated player
            if (data.players) {
                currentPlayers = data.players;
                updateGamePlayersList(data.players, data.currentPlayer);
            }
            
            // Show message about who was eliminated
            if (data.eliminatedPlayerName) {
                showSuccess(`${data.eliminatedPlayerName} wurde eliminiert und ist jetzt Zuschauer.`);
            }
        });
        
        // Handle immediate vote feedback
        socket.on('vote_submitted', (data) => {
            if (data.hideVotingInterface) {
                // Hide all voting interfaces immediately
                document.getElementById('continue-voting').classList.add('hidden');
                document.getElementById('imposter-voting').classList.add('hidden');
                document.getElementById('continue-voting-inline').classList.add('hidden');
                document.getElementById('imposter-voting-inline').classList.add('hidden');
                
                // Disable all voting buttons (including hiding player vote buttons)
                disableVotingButtons();
                
                // Show voting status indicating the player has voted
                const votingStatus = document.getElementById('voting-status-inline') || document.getElementById('voting-status');
                if (votingStatus) {
                    votingStatus.innerHTML = '<p style="color: #90EE90; text-align: center; font-weight: bold;">‚úÖ Du hast abgestimmt! Warten auf andere Spieler...</p>';
                }
                
                // Show the feedback message
                if (data.message) {
                    showSuccess(data.message);
                }
            }
        });
        
        // Handle voting end
        socket.on('voting_ended', (data) => {
            console.log('Voting ended with data:', data);
            
            // Show voting result overlay if we have result data
            if (data.resultType) {
                showVotingResultOverlay({
                    type: data.resultType,
                    eliminatedPlayer: data.eliminatedPlayer,
                    currentRound: data.currentRound,
                    nextRound: data.nextRound,
                    message: data.message
                });
                
                // After overlay is shown, proceed with normal voting end logic after 5 seconds
                setTimeout(() => {
                    proceedAfterVotingResult(data);
                }, 5000);
            } else {
                // Fallback to immediate processing if no result data
                proceedAfterVotingResult(data);
            }
        });
        
        function proceedAfterVotingResult(data) {
            console.log('=== proceedAfterVotingResult called ===');
            console.log('üìä data:', data);
            console.log('üó≥Ô∏è hasVoted before processing:', hasVoted);
            console.log('üéØ currentVotingType before processing:', currentVotingType);
            console.log('üéÆ data.resultType:', data.resultType);
            console.log('üëÅÔ∏è data.hideVotingInterface:', data.hideVotingInterface);
            
            if (data.hideVotingInterface) {
                console.log('Hiding voting interfaces...');
                
                // CACHE-BUSTER v1.2: For imposter voting, don't hide the interface immediately - keep it visible during overlay
                if (data.resultType === 'imposter_voting') {
                    console.log('üîç IMPOSTER VOTING - keeping voting interface visible during overlay');
                    // Don't hide voting interfaces yet, they will be handled after the overlay
                } else {
                    console.log('üì§ OTHER VOTING TYPE - hiding voting interfaces immediately');
                    // Hide all voting interfaces for other result types
                    document.getElementById('voting-screen').classList.add('hidden');
                    document.getElementById('continue-voting').classList.add('hidden');
                    document.getElementById('imposter-voting').classList.add('hidden');
                    document.getElementById('continue-voting-inline').classList.add('hidden');
                    document.getElementById('imposter-voting-inline').classList.add('hidden');
                    document.getElementById('voting-section').classList.add('hidden');
                }
                
                // Reset voting state and enable buttons (including showing player vote buttons again)
                hasVoted = false;
                currentVotingType = null; // Reset voting type
                enableVotingButtons();
                
                console.log('hasVoted after reset:', hasVoted);
                console.log('currentVotingType after reset:', currentVotingType);
                
                // Only show game interface if we're not switching to a new voting phase
                // Check if this is switching to imposter voting or continuing game
                if (data.resultType === 'imposter_voting') {
                    // Don't show game-info yet, wait for vote_updated to show voting interface
                    console.log('Switching to imposter voting - waiting for vote_updated');
                } else {
                    // Show game interface again for other cases (continue, eliminated player, etc.)
                    document.getElementById('game-info').classList.remove('hidden');
                }
                
                // Show the feedback message only if no overlay was shown
                if (data.message && !data.resultType) {
                    showSuccess(data.message);
                }
            }
            console.log('=== proceedAfterVotingResult completed ===');
        }
        
        // Helper Functions
        function copyMatchLink() {
            if (!currentMatchId) {
                showError('Keine aktive Match-ID');
                return;
            }
            
            const matchUrl = `${window.location.origin}/match/${currentMatchId}`;
            
            // Try modern clipboard API first
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(matchUrl).then(() => {
                    showSuccess('Match-Link kopiert!');
                }).catch(err => {
                    // Fallback method
                    fallbackCopyText(matchUrl);
                });
            } else {
                // Fallback method for older browsers
                fallbackCopyText(matchUrl);
            }
        }
        
        function fallbackCopyText(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showSuccess('Match-Link kopiert!');
                } else {
                    showError('Kopieren fehlgeschlagen');
                }
            } catch (err) {
                showError('Kopieren fehlgeschlagen');
            }
            
            document.body.removeChild(textArea);
        }
        
        function getPlayerName() {
            if (myPlayerName) {
                return myPlayerName;
            }
            
            const hostNameInput = document.getElementById('host-name');
            const joinNameInput = document.getElementById('join-name');
            
            if (hostNameInput && hostNameInput.value) {
                return hostNameInput.value;
            }
            
            if (joinNameInput && joinNameInput.value) {
                return joinNameInput.value;
            }
            
            return null;
        }
        
        function updatePlayersList(players) {
            const listDiv = document.getElementById('players-list');
            listDiv.innerHTML = '<h3>Spieler (' + players.length + '/8):</h3>';
            
            console.log('Updating players list with:', players); // Debug
            
            players.forEach(player => {
                console.log(`Processing player ${player.name} with avatar:`, player.avatar); // Debug
                
                const playerDiv = document.createElement('div');
                playerDiv.className = 'player-item';
                
                // Create avatar container
                const avatarContainer = document.createElement('div');
                avatarContainer.className = 'player-avatar avatar-container';
                
                const avatarImg = document.createElement('img');
                const avatarPath = getAvatarImagePath(player.avatar);
                avatarImg.src = avatarPath;
                avatarImg.alt = `${player.name} Avatar`;
                
                // Debug: Log avatar loading
                console.log(`Loading avatar for ${player.name}:`, player.avatar, '-> path:', avatarPath);
                
                // Add error handler for avatar images
                avatarImg.onerror = function() {
                    console.error(`Failed to load avatar for ${player.name}:`, this.src);
                    this.src = '/images/avatare/standard.png'; // Fallback
                };
                
                avatarContainer.appendChild(avatarImg);
                
                // Add frame if exists
                if (player.avatar && (player.avatar.frame > 0 || player.avatar.frame === 'rainbow')) {
                    const frameImg = document.createElement('img');
                    frameImg.src = getFrameImagePath(player.avatar);
                    frameImg.className = 'avatar-frame';
                    frameImg.alt = 'Avatar Rahmen';
                    avatarContainer.appendChild(frameImg);
                }
                
                // Create player info
                const playerInfo = document.createElement('div');
                playerInfo.className = 'player-info';
                
                const playerName = document.createElement('div');
                playerName.className = 'player-name';
                playerName.textContent = player.name;
                
                if (player.isHost) {
                    const hostBadge = document.createElement('span');
                    hostBadge.className = 'host-badge';
                    hostBadge.textContent = 'Host';
                    playerName.appendChild(hostBadge);
                }
                
                playerInfo.appendChild(playerName);
                
                // Assemble player item
                playerDiv.appendChild(avatarContainer);
                playerDiv.appendChild(playerInfo);
                
                listDiv.appendChild(playerDiv);
            });
        }
        
        // Store all words from all rounds
        let allRounds = [];
        
        function updateWordsList(words, round = null) {
            console.log('updateWordsList called with:', { words, round, allRoundsLength: allRounds.length });
            
            // If we have a specific round, update our stored rounds
            if (round && words.length > 0) {
                console.log('Adding/updating round:', round, 'with words:', words);
                // Check if this round already exists
                const existingRoundIndex = allRounds.findIndex(r => r.round === round);
                if (existingRoundIndex >= 0) {
                    allRounds[existingRoundIndex] = { round: round, words: words };
                } else {
                    allRounds.push({ round: round, words: words });
                }
            }
            
            // Always refresh the display
            displayAllRounds();
        }
        
        function displayAllRounds() {
            console.log('displayAllRounds called, allRounds:', allRounds);
            const listDiv = document.getElementById('words-list');
            console.log('words-list element found:', !!listDiv);
            
            if (!listDiv) {
                console.error('words-list element not found!');
                return;
            }
            
            // Clear the display
            listDiv.innerHTML = '';
            
            console.log('Final allRounds before display:', allRounds);
            if (allRounds.length === 0) {
                console.log('No rounds to display - allRounds is empty');
                return;
            }
            
            console.log('About to display', allRounds.length, 'rounds');
            
            // Display all rounds (newest first, oldest last)
            allRounds.slice().reverse().forEach(roundData => {
                const roundTitle = document.createElement('h3');
                roundTitle.textContent = `Runde ${roundData.round}:`;
                roundTitle.style.marginTop = '20px';
                roundTitle.style.marginBottom = '10px';
                roundTitle.style.color = '#ffeb3b';
                listDiv.appendChild(roundTitle);
                
                roundData.words.forEach(wordEntry => {
                    const wordDiv = document.createElement('div');
                    wordDiv.className = 'word-entry';
                    wordDiv.innerHTML = `
                        <span><strong>${wordEntry.playerName}:</strong></span>
                        <span>${wordEntry.word}</span>
                    `;
                    listDiv.appendChild(wordDiv);
                });
            });
        }
        
        // Test function to debug rounds display
        function testRoundsDisplay() {
            console.log('Test: Current allRounds:', allRounds);
            console.log('Test: allRounds length:', allRounds.length);
            if (allRounds.length > 0) {
                console.log('Test: Calling displayAllRounds()');
                displayAllRounds();
            } else {
                console.log('Test: No rounds to display');
            }
        }
        
        // Make test function globally available
        window.testRoundsDisplay = testRoundsDisplay;
        
        function updateVotingPlayers(players) {
            const voteDiv = document.getElementById('vote-players');
            voteDiv.innerHTML = '';
            
            // If current user is a spectator, don't show any voting buttons
            if (isSpectator) {
                voteDiv.innerHTML = '<p style="color: #666; text-align: center;">Zuschauer k√∂nnen nicht abstimmen</p>';
                return;
            }
            
            // Don't create buttons if user has already voted
            if (hasVoted) {
                voteDiv.innerHTML = '<p style="color: #90EE90; text-align: center; font-weight: bold;">‚úÖ Du hast bereits abgestimmt!</p>';
                return;
            }
            
            // Filter out spectators (eliminated players) and the current player (can't vote for themselves)
            const currentPlayerName = getPlayerName();
            const activePlayers = players.filter(player => 
                !player.isSpectator && player.name !== currentPlayerName
            );
            
            activePlayers.forEach(player => {
                const button = document.createElement('button');
                button.className = 'vote-player-btn';
                button.textContent = player.name;
                button.onclick = () => vote('imposter', player.id);
                voteDiv.appendChild(button);
            });
        }
        
        function updateVotingPlayersInline(players) {
            console.log('updateVotingPlayersInline called, hasVoted:', hasVoted, 'isSpectator:', isSpectator);
            const voteDiv = document.getElementById('vote-players-inline');
            voteDiv.innerHTML = '';
            
            // If current user is a spectator, don't show any voting buttons
            if (isSpectator) {
                voteDiv.innerHTML = '<p style="color: #666; text-align: center;">Zuschauer k√∂nnen nicht abstimmen</p>';
                return;
            }
            
            // Don't create buttons if user has already voted
            if (hasVoted) {
                voteDiv.innerHTML = '<p style="color: #90EE90; text-align: center; font-weight: bold;">‚úÖ Du hast bereits abgestimmt!</p>';
                return;
            }
            
            // Filter out spectators (eliminated players) and the current player (can't vote for themselves)
            const currentPlayerName = getPlayerName();
            const activePlayers = players.filter(player => 
                !player.isSpectator && player.name !== currentPlayerName
            );
            
            console.log('Creating voting buttons for', activePlayers.length, 'active players (filtered from', players.length, 'total players, excluding self)');
            activePlayers.forEach(player => {
                const button = document.createElement('button');
                button.className = 'vote-player-btn';
                button.textContent = player.name;
                button.onclick = () => vote('imposter', player.id);
                voteDiv.appendChild(button);
            });
        }
        
        // Lobby Functions
        function updateLobby(matches) {
            const lobbyDiv = document.getElementById('lobby-matches');
            lobbyDiv.innerHTML = '';
            
            if (matches.length === 0) {
                const noMatchesDiv = document.createElement('div');
                noMatchesDiv.className = 'no-matches';
                noMatchesDiv.textContent = 'Keine Spiele verf√ºgbar';
                lobbyDiv.appendChild(noMatchesDiv);
                return;
            }
            
            matches.forEach(match => {
                const matchDiv = document.createElement('div');
                matchDiv.className = 'lobby-match';
                
                // Private Lobby Styling
                if (match.isPrivate) {
                    matchDiv.classList.add('private-lobby');
                }
                
                const privateIndicator = match.isPrivate ? 
                    `<span class="private-indicator">üîí Privat</span>` : 
                    `<span class="public-indicator">üåê √ñffentlich</span>`;
                
                matchDiv.innerHTML = `
                    <div class="lobby-match-info">
                        <div class="lobby-match-host">Host: ${match.hostName} ${privateIndicator}</div>
                        <div class="lobby-match-players">${match.playerCount}/8 Spieler</div>
                        <div style="font-size: 0.8em; color: #999;">ID: ${match.id}</div>
                    </div>
                    <button class="lobby-match-join" onclick="joinMatchWithPassword('${match.id}', ${match.isPrivate})">
                        ${match.isPrivate ? 'Mit Passwort beitreten' : 'Beitreten'}
                    </button>
                `;
                lobbyDiv.appendChild(matchDiv);
            });
        }
        
        function quickJoinMatch(matchId) {
            if (!currentUser) {
                showError('Du musst eingeloggt sein');
                return;
            }

            socket.emit('join_match', {
                matchId: matchId,
                password: ''
            });
        }
        
        function joinMatchById(matchId) {
            if (!currentUser) {
                showError('Du musst eingeloggt sein');
                return;
            }
            
            console.log('Trying to join match from URL:', matchId);
            
            // Try to join without password first
            socket.emit('join_match', {
                matchId: matchId,
                password: ''
            });
        }
        
        function joinMatchWithPassword(matchId, isPrivate) {
            if (!currentUser) {
                showError('Du musst eingeloggt sein');
                return;
            }
            
            let password = '';
            if (isPrivate) {
                password = prompt('Passwort f√ºr private Lobby:');
                if (password === null) return; // User cancelled
            }
            
            socket.emit('join_match', {
                matchId: matchId,
                password: password
            });
        }        
        
        // Socket Events for Auth
        socket.on('login_result', (data) => {
            if (data.success) {
                console.log('Socket login successful');
                
                // Check if user was in a match and restore it
                if (data.currentMatch) {
                    console.log('Restoring previous match:', data.currentMatch.id);
                    console.log('Full currentMatch object:', data.currentMatch);
                    console.log('currentMatch.allRounds:', data.currentMatch.allRounds);
                    currentMatchId = data.currentMatch.id;
                    updateURL(data.currentMatch.id); // Update URL when restoring match
                    hideAllScreens();
                    
                    // Check if it's an active game or waiting room
                    if (data.currentMatch.gameState === 'waiting') {
                        // Restore to waiting room/lobby
                        document.getElementById('waiting-room').classList.remove('hidden');
                        document.getElementById('user-profile').classList.remove('hidden');
                        currentPlayers = data.currentMatch.players || [];
                        updatePlayersList(data.currentMatch.players);
                        
                        // Check if user is host and update status
                        const userPlayer = data.currentMatch.players.find(p => p.name === myPlayerName);
                        if (userPlayer && userPlayer.isHost) {
                            isHost = true;
                            console.log('You are the host of this match');
                        } else {
                            isHost = false;
                        }
                        updateStartGameButton();
                    } else {
                        // Restore to active game
                        document.getElementById('user-profile').classList.remove('hidden');
                        
                        // Load all rounds data if available
                        console.log('Rejoin - checking allRounds:', data.currentMatch.allRounds);
                        console.log('Rejoin - wordsThisRound:', data.currentMatch.wordsThisRound);
                        console.log('Rejoin - currentRound:', data.currentMatch.currentRound);
                        
                        if (data.currentMatch.allRounds && data.currentMatch.allRounds.length > 0) {
                            allRounds = data.currentMatch.allRounds;
                            console.log('Rejoin - allRounds loaded:', allRounds);
                            // Force display all rounds with a small delay to ensure DOM is ready
                            setTimeout(() => {
                                console.log('Delayed displayAllRounds call');
                                displayAllRounds();
                            }, 100);
                        } else {
                            console.log('Rejoin - No allRounds data available');
                        }
                        
                        // Show voting section if in voting state
                        if (data.currentMatch.gameState === 'voting_continue' || data.currentMatch.gameState === 'voting_imposter') {
                            hasVoted = false; // Reset voting flag when rejoining
                            enableVotingButtons(); // Enable buttons when rejoining
                            
                            document.getElementById('game-screen').classList.remove('hidden');
                            document.getElementById('game-info').classList.add('hidden');
                            document.getElementById('voting-section').classList.remove('hidden');
                            
                            if (data.currentMatch.gameState === 'voting_continue') {
                                document.getElementById('continue-voting-inline').classList.remove('hidden');
                                document.getElementById('imposter-voting-inline').classList.add('hidden');
                            } else {
                                document.getElementById('continue-voting-inline').classList.add('hidden');
                                document.getElementById('imposter-voting-inline').classList.remove('hidden');
                                updateVotingPlayersInline(data.currentMatch.players);
                            }
                            
                            // Update voting status when rejoining
                            updateVotingStatus(data.currentMatch.players, data.currentMatch.votes || []);
                        } else {
                            // Show game screen for normal gameplay
                            document.getElementById('game-screen').classList.remove('hidden');
                            document.getElementById('game-info').classList.remove('hidden');
                            document.getElementById('voting-section').classList.add('hidden');
                            updateMatchDisplay(data.currentMatch);
                        }
                    }
                } else {
                    // Check for pending match ID from URL
                    const pendingMatchId = sessionStorage.getItem('pendingMatchId');
                    if (pendingMatchId) {
                        sessionStorage.removeItem('pendingMatchId');
                        joinMatchById(pendingMatchId);
                    }
                }
            } else {
                console.error('Socket login failed:', data.message);
                // If socket login fails, logout user
                logout();
            }
        });
        
        socket.on('force_logout', (data) => {
            logout();
            setTimeout(() => {
                showError(data.message || 'Du wurdest von einem anderen Ger√§t ausgeloggt.');
            }, 100);
        });
        
        socket.on('player_reconnected', (data) => {
            console.log(`${data.username} ist wieder da!`);
            // Optionally show a notification
        });
        
        // Update stats when they change
        socket.on('stats_updated', (data) => {
            console.log('Stats updated:', data.user.stats);
            // Update the stored user data
            if (data.user && data.user.stats) {
                // Update global currentUser if it exists
                if (currentUser && currentUser.username === data.user.username) {
                    currentUser.stats = data.user.stats;
                    // Update localStorage as well
                    localStorage.setItem('currentUser', JSON.stringify(currentUser));
                }
                
                // Find and update user stats display if stats screen is visible
                if (!document.getElementById('stats-screen').classList.contains('hidden')) {
                    // Refresh the stats display
                    showStats();
                }
                
                // Show a brief notification that stats were updated
                showSuccess('Statistiken aktualisiert!');
            }
        });
        
        // Socket Events for Lobby
        socket.on('lobby_updated', (data) => {
            updateLobby(data.matches);
        });
        
        // Enter key support
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                if (!document.getElementById('word-input-section').classList.contains('hidden')) {
                    submitWord();
                }
            }
        });
    </script>
</body>
</html>
